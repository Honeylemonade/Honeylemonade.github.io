{"pages":[],"posts":[{"title":"My First Blog","text":"My First Blog经历了大约两天的时间，终于将博客改造成了自己喜欢的形式 从真正开始接触计算机，到现在，也已经大概两年的时间了，对于知识的管理，经历了很多阶段。从一开始的纸质笔记本，到x-mind文档，再到Markdown笔记。虽然，期间经历过资料的损坏，丢失，但现在仍保存着绝大部分的内容。现在决定转换阵地——博客。 首先，我并不是一个所谓的”技术宅“，我对生活的也是充满着热情的，也有很多想要尝试，去做的事情，像是： 去学习有关人体构造以及运动学方面的知识 去学唱歌，并掌握一种乐器 去了解经济学，对自己的财政情况时刻保持清醒的认识 学习室内设计，在将来有自己的房子的时候，可以进行DIY 所以，博客的内容将不仅限于计算机方面的知识，在未来，也会包含运动，音乐，经济学相关的内容。当然，在这个过程中，相信我的文笔也会越来越好。 正如本文的配图——“Let‘s have a hike.” 这不仅是一个新的起点，也是一个不断积累的过程。愿我可以成为我想成为的人。","link":"/2019/11/17/%E5%85%B6%E4%BB%96/My%20First%20Blog/"},{"title":"【Java】简介及基础概念","text":"Java简介Java的发源1991年1月，一个名为“Green Project”的项目启动。该项目旨在为家用电器提供支持，使这些电器智能化并且能够彼此交互，而且这些家电可以由远程客户端控制。Bill Joy、James Gosling、Mike Sheradin和Patrick Naughton是该项目的核心成员。 JAVA原名是“Oak”，橡树的意思，但后来发现有已经有编程语言叫做Oak，所以改名为JAVA Java语言发展情况 版本 年份 新特性 1.0 1996 语言本身 1.1 1997 内部类 1.2 1998 strictfp修饰符 1.3 2000 无 1.4 2002 断言 5.0 2004 泛型类，for each，循环，自动装箱，枚举，静态导入 6 2006 无 7 2011 基于字串的switch，钻石操作符，二进制字面量，异常处理的改进 8 2014 lambda表达式，包含默认方法的接口，流和日期/时间库 Java基础概念注释注释共分为三种： //：简单的注释 /* */：比较长的注释，可以是多行 /** */：javadoc，会自动的生成文档 基本数据类型Java共有8种数据类型，包括4个整型，2个浮点型，1个字符型，1个boolean型 序号 数据类型 封装类 默认值 可表示范围 特征 1 byte(字节) Byte 0 -128~127 一个字节 2 short(短整数) Short 0 -32768~32767 两个字节 3 int(整数) Integer 0 -2147483648~2147483647 四个字节 4 long(长整数) Long 0L -9223372036854775808~9223372036854775807 八个字节 5 float(单精度) Float 0.0F 1.4E-45~3.4028235E38 6 double(双精度) Double 0.0D 4.9E-324~1.7976931348623157E308 7 char(字符) Character ‘’ 0~65535 8 boolean（布尔值） Boolean false true或false Tips： java没有无符号类型 int int型数较大，不方便观察时，可以使用_（下划线）进行分隔，例如：int a = 800_0000; 内存中存储的实际上是整形的补码 0x开头代表16进制，0开头代表8进制 long 长整型数值后面有一个L后缀：4000000000L 浮点型 浮点型不能用于金融的计算，比如：2.0-1.1=0.8999999，是因为二进制不能精确的表示1/10，就像十进制不能精确表示1/3（应该使用BigDecimal类） char型 JAVA中所有的字符类型都占用2个字节，包括中文和英文 boolean Java中的boolean（布尔）类型不能和整型相互转换 字符串String为了节省内存空间，JVM底层对String类型进行了优化，存在着“常量池”。 一个对象在常量池中，当有需要时，直接使用常量池中的引用，而不是重新创建，这样可以节约空间，提高性能。 由于是常量，不存在“改变”，所以完全不用担心多个代码块对同一引用的使用会造成错误。 123456789101112131415public static void main(String[] args) { //先去String常量池中查找是否已经存在“abc” //没有找到，则在String常量池中新建“abc”字符串常量 String a = \"abc\"; //在String常量池中找到“abc”，将其引用直接赋值给变量 String b = \"abc\"; //直接new String（“abc”）创建一个新的字符串对象，创建的对象不在字符串常量池中 String c = new String(\"abc\"); //结果为true System.out.println(a == b); //结果为false System.out.println(a == c); //结果为true System.out.println(a.equals(c)); } Tips String不可变，但可以修改其引用，达到修改某个变量的目的 当字符串+=后，会生成新的字符串对象 判断字串是否相同，要用equals（）方法，直接使用==判断的是两个引用是否为同一个，不同引用的字符串可能相同的 if( str !=null &amp;&amp; str.length() !=0 )判断字符串长度时，要先判断其是否为null，然后再判断长度，这里利用了&amp;&amp;的短路功能 运算符算数运算法 +，-，*，/ ++，– %：取余数 这里要注意取余和取模的区别，这两者的基本步骤相同： 求整数商：c=a/b 计算余数或模：r=a-c*b 两者的不同在于第一步：“求整数商” 取模求时，第一步的商向0方向舍入 而求余时，第一步的商向负无穷方向舍入 例如：7和-2做取余和取模运算 步骤 求余数 求模数 1 7/-2=-3.5，商向0舍入，∴c=-3 7/-2=-3.5，商向负无穷舍入，∴c=-4 2 r=a-c*b=1 r=a-c*b=-1 123456public void test() { //取余，结果为1 System.out.println(7 % -2); //取模，结果为-1 System.out.println(Math.floorMod(7, -2)); } 位运算符 &amp;，|，~，^：按顺序分别是与，或，非，异或 &lt;&lt;，&gt;&gt;：左移和右移 &gt;&gt;&gt;无符号右移 逻辑运算符 &amp;，|，！，^：与，或，非，异或 &amp;&amp;，||：短路与，短路或 Tips 整数被0除将会产生异常，而浮点数被0除，会得到无穷大或者NaN（Not a Number）的结果 负数的%(取余)，可能会取到负数 数学Math类： 平方根，幂运算， Math的floorMod求模 Math提供了近似于PI和E的常量：Math.PI和Math.E 想要进行四舍五入运算可以使用Math.round() Math.random()生成随机数 &amp;&amp;和||是逻辑运算符，做的是短路操作，既当前一部分已经确定true或者false后，后一部分将不再进行运算 位运算符 1234567891011121314151617181920212223242526public static void main(String[] args) { /**--------------------------------------------------- * ^(亦或运算)：相同的为0，不同的为1 * 2 =======&gt;0010 * 3 =======&gt;0011 * 2^3就为0001，结果就是1 *--------------------------------------------------- * &amp;（与运算）：有一个为0，就是0 * 2 =======&gt;0010 * 3 =======&gt;0011 * 2&amp;3就为0010，结果就是2 *--------------------------------------------------- * 另外还有|或运算，~非运算 *--------------------------------------------------- * &lt;&lt;(向左位移) * 2 =======&gt;0010 * 向左移3位，可以理解成称了3次2 * 2&lt;&lt;3运算的结果是 :16 *--------------------------------------------------- * &gt;&gt;(向右位移)：同上 *--------------------------------------------------- * &gt;&gt;&gt;(无符号右移) :不常用，涉及到补码， * 正数做&gt;&gt;&gt;运算的时候和&gt;&gt;是一样的。区别在于负数运算 * --------------------------------------------------- */ } 类型转换数据之间进行类型转换时，常用如下几种方法：截断，包装类方法 截断截断包括两类： 高精度截断为低精度 123456public static void main(String[] args) { double a=9.9997; int b=(int)a; //输出结果为9 System.out.println(b);} 大范围截断为小范围 12345public static void main(String[] args) { int a = (byte) 300; //输出结果为44 System.out.println(a); } 包装类1包装类.valueOf(); 控制流程常用的控制流程语句 if else while，do while for for each switch 方法方法的组成 修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。 返回值类型 ：方法可能会返回值。但有些没有返回值。在这种情况下，returnValueType 是关键字void。 方法名：是方法的实际名称。方法名和参数表共同构成方法签名。 参数类型：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。 方法体：方法体包含具体的语句，定义该方法的功能。 构造方法当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。 通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。 不管你是否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，默认构造方法的访问修改符和类的访问修改符相同(类为 public，构造函数也为 public；类改为 private，构造函数也改为 private)。 一旦你定义了自己的构造方法，默认构造方法就会失效。 finalize() 方法Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( ) 例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。 在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。 方法重载方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。 原则如下： 方法名一定要相同。 方法的参数表必须不同，包括参数的类型或个数，以此区分不同的方法体。 方法的返回类型、修饰符可以相同，也可不同。","link":"/2019/11/18/IT/java/%E3%80%90Java%E3%80%91%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"}],"tags":[{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"IT","slug":"IT","link":"/categories/IT/"},{"name":"Java","slug":"IT/Java","link":"/categories/IT/Java/"}]}
{"pages":[],"posts":[{"title":"My First Blog","text":"My First Blog经历了大约两天的时间，终于将博客改造成了自己喜欢的形式 从真正开始接触计算机，到现在，也已经大概两年的时间了，对于知识的管理，经历了很多阶段。从一开始的纸质笔记本，到x-mind文档，再到Markdown笔记。虽然，期间经历过资料的损坏，丢失，但现在仍保存着绝大部分的内容。现在决定转换阵地——博客。 首先，我并不是一个所谓的”技术宅“，我对生活的也是充满着热情的，也有很多想要尝试，去做的事情，像是： 去学习有关人体构造以及运动学方面的知识 去学唱歌，并掌握一种乐器 去了解经济学，对自己的财政情况时刻保持清醒的认识 学习室内设计，在将来有自己的房子的时候，可以进行DIY 所以，博客的内容将不仅限于计算机方面的知识，在未来，也会包含运动，音乐，经济学相关的内容。当然，在这个过程中，相信我的文笔也会越来越好。 正如本文的配图——“Let‘s have a hike.” 这不仅是一个新的起点，也是一个不断积累的过程。愿我可以成为我想成为的人。","link":"/2019/11/17/%E5%85%B6%E4%BB%96/My%20First%20Blog/"},{"title":"【Java】简介及基础概念","text":"Java简介Java的发源1991年1月，一个名为“Green Project”的项目启动。该项目旨在为家用电器提供支持，使这些电器智能化并且能够彼此交互，而且这些家电可以由远程客户端控制。Bill Joy、James Gosling、Mike Sheradin和Patrick Naughton是该项目的核心成员。 JAVA原名是“Oak”，橡树的意思，但后来发现有已经有编程语言叫做Oak，所以改名为JAVA Java语言发展情况 版本 年份 新特性 1.0 1996 语言本身 1.1 1997 内部类 1.2 1998 strictfp修饰符 1.3 2000 无 1.4 2002 断言 5.0 2004 泛型类，for each，循环，自动装箱，枚举，静态导入 6 2006 无 7 2011 基于字串的switch，钻石操作符，二进制字面量，异常处理的改进 8 2014 lambda表达式，包含默认方法的接口，流和日期/时间库 Java基础概念注释注释共分为三种： //：简单的注释 /* */：比较长的注释，可以是多行 /** */：javadoc，会自动的生成文档 基本数据类型Java共有8种数据类型，包括4个整型，2个浮点型，1个字符型，1个boolean型 序号 数据类型 封装类 默认值 可表示范围 特征 1 byte(字节) Byte 0 -128~127 一个字节 2 short(短整数) Short 0 -32768~32767 两个字节 3 int(整数) Integer 0 -2147483648~2147483647 四个字节 4 long(长整数) Long 0L -9223372036854775808~9223372036854775807 八个字节 5 float(单精度) Float 0.0F 1.4E-45~3.4028235E38 6 double(双精度) Double 0.0D 4.9E-324~1.7976931348623157E308 7 char(字符) Character ‘’ 0~65535 8 boolean（布尔值） Boolean false true或false Tips： java没有无符号类型 int int型数较大，不方便观察时，可以使用_（下划线）进行分隔，例如：int a = 800_0000; 内存中存储的实际上是整形的补码 0x开头代表16进制，0开头代表8进制 long 长整型数值后面有一个L后缀：4000000000L 浮点型 浮点型不能用于金融的计算，比如：2.0-1.1=0.8999999，是因为二进制不能精确的表示1/10，就像十进制不能精确表示1/3（应该使用BigDecimal类） char型 JAVA中所有的字符类型都占用2个字节，包括中文和英文 boolean Java中的boolean（布尔）类型不能和整型相互转换 字符串String为了节省内存空间，JVM底层对String类型进行了优化，存在着“常量池”。 一个对象在常量池中，当有需要时，直接使用常量池中的引用，而不是重新创建，这样可以节约空间，提高性能。 由于是常量，不存在“改变”，所以完全不用担心多个代码块对同一引用的使用会造成错误。 123456789101112131415public static void main(String[] args) { //先去String常量池中查找是否已经存在“abc” //没有找到，则在String常量池中新建“abc”字符串常量 String a = \"abc\"; //在String常量池中找到“abc”，将其引用直接赋值给变量 String b = \"abc\"; //直接new String（“abc”）创建一个新的字符串对象，创建的对象不在字符串常量池中 String c = new String(\"abc\"); //结果为true System.out.println(a == b); //结果为false System.out.println(a == c); //结果为true System.out.println(a.equals(c)); } Tips String不可变，但可以修改其引用，达到修改某个变量的目的 当字符串+=后，会生成新的字符串对象 判断字串是否相同，要用equals（）方法，直接使用==判断的是两个引用是否为同一个，不同引用的字符串可能相同的 if( str !=null &amp;&amp; str.length() !=0 )判断字符串长度时，要先判断其是否为null，然后再判断长度，这里利用了&amp;&amp;的短路功能 运算符算数运算法 +，-，*，/ ++，– %：取余数 这里要注意取余和取模的区别，这两者的基本步骤相同： 求整数商：c=a/b 计算余数或模：r=a-c*b 两者的不同在于第一步：“求整数商” 取模求时，第一步的商向0方向舍入 而求余时，第一步的商向负无穷方向舍入 例如：7和-2做取余和取模运算 步骤 求余数 求模数 1 7/-2=-3.5，商向0舍入，∴c=-3 7/-2=-3.5，商向负无穷舍入，∴c=-4 2 r=a-c*b=1 r=a-c*b=-1 123456public void test() { //取余，结果为1 System.out.println(7 % -2); //取模，结果为-1 System.out.println(Math.floorMod(7, -2)); } 位运算符 &amp;，|，~，^：按顺序分别是与，或，非，异或 &lt;&lt;，&gt;&gt;：左移和右移 &gt;&gt;&gt;无符号右移 逻辑运算符 &amp;，|，！，^：与，或，非，异或 &amp;&amp;，||：短路与，短路或 Tips 整数被0除将会产生异常，而浮点数被0除，会得到无穷大或者NaN（Not a Number）的结果 负数的%(取余)，可能会取到负数 数学Math类： 平方根，幂运算， Math的floorMod求模 Math提供了近似于PI和E的常量：Math.PI和Math.E 想要进行四舍五入运算可以使用Math.round() Math.random()生成随机数 &amp;&amp;和||是逻辑运算符，做的是短路操作，既当前一部分已经确定true或者false后，后一部分将不再进行运算 位运算符 1234567891011121314151617181920212223242526public static void main(String[] args) { /**--------------------------------------------------- * ^(亦或运算)：相同的为0，不同的为1 * 2 =======&gt;0010 * 3 =======&gt;0011 * 2^3就为0001，结果就是1 *--------------------------------------------------- * &amp;（与运算）：有一个为0，就是0 * 2 =======&gt;0010 * 3 =======&gt;0011 * 2&amp;3就为0010，结果就是2 *--------------------------------------------------- * 另外还有|或运算，~非运算 *--------------------------------------------------- * &lt;&lt;(向左位移) * 2 =======&gt;0010 * 向左移3位，可以理解成称了3次2 * 2&lt;&lt;3运算的结果是 :16 *--------------------------------------------------- * &gt;&gt;(向右位移)：同上 *--------------------------------------------------- * &gt;&gt;&gt;(无符号右移) :不常用，涉及到补码， * 正数做&gt;&gt;&gt;运算的时候和&gt;&gt;是一样的。区别在于负数运算 * --------------------------------------------------- */ } 类型转换数据之间进行类型转换时，常用如下几种方法：截断，包装类方法 截断截断包括两类： 高精度截断为低精度 123456public static void main(String[] args) { double a=9.9997; int b=(int)a; //输出结果为9 System.out.println(b);} 大范围截断为小范围 12345public static void main(String[] args) { int a = (byte) 300; //输出结果为44 System.out.println(a); } 包装类1包装类.valueOf(); 控制流程常用的控制流程语句 if else while，do while for for each switch 方法方法的组成 修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。 返回值类型 ：方法可能会返回值。但有些没有返回值。在这种情况下，returnValueType 是关键字void。 方法名：是方法的实际名称。方法名和参数表共同构成方法签名。 参数类型：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。 方法体：方法体包含具体的语句，定义该方法的功能。 方法参数的值传递首先，我们要知道Java方法参数总是按值调用，也就是说，方法得到的参数，是一个变量的值的拷贝。 方法参数共有两种类型： 对于基本数据类型来说，传递的是拷贝的值 对于对象来说，传递的是对象的引用 构造方法当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。 通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。 不管你是否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，默认构造方法的访问修改符和类的访问修改符相同(类为 public，构造函数也为 public；类改为 private，构造函数也改为 private)。 一旦你定义了自己的构造方法，默认构造方法就会失效。 finalize() 方法Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( ) 例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。 在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。 方法重载方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。 原则如下： 方法名一定要相同。 方法的参数表必须不同，包括参数的类型或个数，以此区分不同的方法体。 方法的返回类型、修饰符可以相同，也可不同。","link":"/2019/11/18/IT/java/%E3%80%90Java%E3%80%91%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"title":"【Java】继承与接口","text":"继承继承的概念继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 兔子和羊属于食草动物类，狮子和豹属于食肉动物类。 食草动物和食肉动物又是属于动物类。 所以继承需要符合的关系是：is-a，父类更通用，子类更具体。 Tips 子类拥有父类非private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，单继承就是一个子类只能继承一个父类。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。 使用final关键字可以阻止子类继承：final关键字不仅可以声明在类上，也可以生命在类方法上 Object类——所有类的父类equals方法用于判断两个对象是否具有相同的引用，代码实现使用的是“==” 123public boolean equals(Object obj) { return (this == obj); } 重写equals方法应该严格按照规定来做，共5步 hashcode方法用于返回一个对象的散列值 应用场景：集合Map，不允许出现相同元素，当我们插入一个对象时，如果使用==一个个的去比较是否是同一对象，在数量少的时候，还可以接受，当数量很大时，一个个去比较，显然很不合理，于是我们可以利用hashcode，直接得出为一的标识，去查找目表对象。 toString方法用于返回对象字符串，常用于打印对象当前的状态信息 cloneable接口用于标识类是可以被复制的，用protected声明 首先我们先理解一下 浅拷贝和 深拷贝 浅拷贝：对象中的深一层对象，采用的是同一个实例引用 深拷贝：对象中的深层对象，采用的是不用的实例引用 实现深拷贝的方法： 实现cloneable接口，并自定义clone方法（比较麻烦） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Data@NoArgsConstructor@AllArgsConstructorpublic class Teacher implements Cloneable { String name; Integer age; @Override public String toString() { return \"Teacher{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); }}@Data@NoArgsConstructor@AllArgsConstructorpublic class MyClass implements Cloneable { Teacher teacher; Integer Number; @Override public String toString() { return \"MyClass{\" + \"teacher=\" + teacher.toString() + \", Number=\" + Number + '}'; } @Override protected Object clone() throws CloneNotSupportedException { MyClass cloned = (MyClass) super.clone(); cloned.teacher = (Teacher) teacher.clone(); return cloned; }} public static void main(String[] args) throws Exception { Teacher teacher = new Teacher(\"王华\", 32); MyClass a = new MyClass(teacher, 100); MyClass b= (MyClass) a.clone(); System.out.println(a.toString()); System.out.println(b.toString()); a.teacher.age=11; System.out.println(a.toString()); System.out.println(b.toString()); } 使用对象的串行化 使用已有的工具包 浅谈多继承的优缺点 C++支持多继承，而很多语言例如，java不支持多继承，“不支持”并不是说技术上难以实现，而是多继承存在一些问题 优点： 有利于类的复用，方便与扩展 缺点： 二义性：如果多个父类的方法名相同，则不知道要调用谁的方法 接口接口的概念 接口（英文：Interface），在Java编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过实现接口，从实现对应的功能。 接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。 接口定义：接口是对类的一组需求的描述，这些类要遵从接口的描述进行定义 接口中的所有方法自动的属于public，因此不需要提供关键字public 接口不能被实例化，但可以声明接口的变量 接口中可以定义常量（但不推荐使用），接口中定义的常量应为所有类频繁使用的常量, 但并不是每个类都使用了接口中定义的所有常量，建议常量定义在实现类中 JAVA只能单继承，但是可以实现多个接口 接口中可以定义静态方法 接口中，使用default关键字定义的方法，可在接口中实现方法体，并且实现该接口的类，可以选择是否重写该接口 接口和继承 继承：继承是一种泛化的过程，使一个抽象的类更加生动具体，更专注于整个类的定义。 实现接口：接口的实现，像是一种功能的补充，至于功能怎么实现，取决于实现该接口的类。","link":"/2019/11/18/IT/java/%E3%80%90Java%E3%80%91%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%8E%A5%E5%8F%A3/"},{"title":"【操作系统】进程，线程与多核处理","text":"进程，线程与多核处理进程 引入进程的目的是为了使多个程序可以并发执行，以提高资源的利用率和系统的吞吐量。、 一，进程的概念 是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。 qq，讯雷等软件工作，内部需要很多个模块相互协调，而这些模块都是一个进程。 程序是一个静态概念，而进程是一个动态的概念，他着眼于活动运行过程。一个程序可以有很多个进程组成，而一个进程又由很多个线程组成。 进程是资源分配和调度的基本单位。 进程的特点： 动态性：由产生，到消亡 并发性：多个进程可以同时装入内存中 独立性：进程是操作系统完成工作的基本单元 异步性：各个并发的进程相互独立 结构性：由程序段，数据段，进程控制块（PCB）组成 二，进程的实体 共由三部分组成 程序：进程运行所对应的执行代码 数据集合：所用到的数据和开辟的工作区域 进程控制块（PCB）： 用于描述和标志进程，包括进程名称，当前状态，进程的优先级等 PCB是进程存在的唯一标志 三，进程的状态与转换 进程的三种基本状态： 就绪状态 执行状态 阻塞状态（等待状态） 四，进程控制 内核：是操作系统中最常用，最核心的内容，他可以对进程进行控制，在操作系统中必须设置一个机构，他具有创建进程，撤销进程以及其他管理功能。 通过内核中定义的“原语”来控制进程，原语可分为四大类： 创建原语 撤销原语 阻塞原语 唤醒原语 原语的特点：一旦执行，不能中断。（注意原语只能对进程操作，而不能操作线程） 线程 引入线程的目的是为了减少某个进程并发执行时所付出的时空开销 一，线程简介 线程是比进程更小的能独立运行的基本单位，因此，在为其创建，撤销和切换时，所需要付出的开销也就更少，因此能显著提高并发的程度。 QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。 线程是系统调度的基本单位 二，线程的状态 与进程类似，也包含： 就绪状态 执行状态 阻塞状态（等待状态） 三，线程的控制 线程的控制是通过操作系统提供的“线程操作库”来控制的。 常见的操作包括： 创建 撤销 等待 线程让权（线程自己放弃cpu的使用） 进程通信和线程通信一个程序至少有一个进程，一个进程至少有一个线程。 进程是内存分配的基本单位； 线程是系统调度的基本单位； 即同一个进程下的所有线程，共有着同一内存空间，所以同一进程间线程通信的方式为： 访问共享变量 ； 不同进程占有不同的内存资源，所以并不能直接通信，需要其他方式，例如： 管道 消息队列 信号量：不能传递复杂消息，只能用来同步 共享内存：使不同进程共享同一块内存，能够很容易控制容量，速度快，但为了安全，要使用同步策略（信号量或PV操作）。 多处理器，超线程和多核你是个包工头，以前你只能指挥1个工人去盖一个房子。你就是一个核心，这1个工人就是一个线程。这叫单核单线程。后来你觉得这么做太慢，一个工人搬砖时候完全可以多点工人去做其他的比如砌墙，打桩。后来你又招了一群工人。这叫单核多线程。再后来你发现，你同时只能指挥一群人盖一个房子，为了加快盖房子速度，你又找了你兄弟做另一个包工头。这样就变成了多核多线程。 多处理器结构： 一个电脑有多个处理器，共同执行任务 成本比较高 超线程： 与一般的并发不同，超线程是真正意义上的并行，宏观和微观上都是真并行的 虽然可以让一个cpu同时执行任务，但是不像多个CPU资源是独立的，还是会存在阻塞的状态 多核结构： 一个CPU有多个执行核，每个核有自己的资源 多核超线程： 就是将多核和超线程结合在一起","link":"/2019/11/21/IT/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86/"},{"title":"【Java】数组与集合","text":"数组 声明数组有两种方式 int[] a 和 int a[]，推荐使用：int[] a（变量类型都在左边） 12345public static void main(String[] args) { //等价于 int[] a=new int[10]; int[] a; a=new int[10]; } 创建数组时，有默认值 数字数组，默认为：0 boolean数组，默认为：false 对象数组，默认为：null 一旦创建数组后，就不能再去改变它的大小 数组之间使用=时，表示两个变量引用同一个数组 如果想要拷贝一个新的数组，可以使用Arrays.copyOf() 数组排序，Arrays.sort(a)，采用了快速排序的方法 123456789//对于情况E，赋值会产生空指针异常。java.lang.NullPointerExceptionfloat [][]f = new float[6][];f[0][1] = 1.0f;System.out.println(f[0][1]);//若要访问，需要创建数组，并指向该地址。float [][]f = new float[6][];f[0] = new float[5];f[0][1] = 1.0f;System.out.println(f[0][1]); 快速初始化数组 1234 boolean[] a=new boolean[10]; Arrays.fill(a,true); System.out.println(a[0]);//输出ture 集合集合体系及特点 这里给出常用的一些接口和实现类，实际上远比这个要复杂：可以使用IDEA查看diagram Collection 是集合类的一个顶级接口 Collection是单列集合 Collection中只有Set系列要求元素唯一 List接口 List是元素有序并且可以重复的集合，称为序列 List可以精确的控制每个元素的插入位置，或删除某个位置的元素 ArrayList类： ArrayList底层是由数组实现的，长度动态增长（没超过边界一次，容量就会自动扩大为原来的1.5倍） 由于是用数组实现的，当在某个不是头尾的位置进行插入删除时，需要移动其位置后面的所有元素，效率很低，所以增删速度慢 由于是用数组实现的，索引速度快，所以更适合查询和更新元素 LinkedList类： 是基于链表结构实现的 基于链表实现，所以查询速度慢 基于链表实现，所以增删速度快 vector类： 底层也是由数组实现的，每次扩容扩大为原来的2倍 Vector 是很多方法都有用synchronize修饰，也就是说，可以做到线程安全，但性能比较低 stack类： 栈 Set接口 Set是元素无序的 元素不可以重复，称为集 HashSet类： HashSet是Set接口的重要实现类，称为哈希集 HashSet中的元素无序并且不可以重复 具有良好的存取和查找性能 TreeSet类： TreeSet是基于二叉树的数据结构 可以在插入的时候，自然的排序 Map Map中的数据是以键值对(key-value)的形式存储的，是双列集合 可以通过key值快速查找value key值不能重复，但是value可以重复 HashMap类： 基于哈希表的Map接口的实现 HashMap中的Entry对象是无序排列的 Tips关于静态容器类的初始化，可以用双花括号解决： 1234567private static ArrayList&lt;Contact&gt; contacts = new ArrayList&lt;Contact&gt;() {{ add(new Contact(5468754, \"a\")); add(new Contact(4468754, \"b\")); add(new Contact(7468754, \"c\")); add(new Contact(2468754, \"d\")); add(new Contact(6468754, \"e\")); }}; 迭代器接口： 用与遍历集合元素的接口，共包含4个方法 next（）：返回值，并且向下移动 hasNext（） remove（） forEachRemaining（） 1234567891011121314@Test public void test() { ArrayList&lt;Integer&gt; list = new ArrayList(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); //获取集合的迭代器 Iterator it = list.iterator(); while (it.hasNext()) { System.out.println(it.next()); } } for-each语法糖： JAVA中for-each的底层实现就是利用了迭代器，for-each其实只是java提供的语法糖。语法糖是编程语言提供的一些便于程序员书写代码的语法，是编译器提供给程序员的糖衣，编译时会对这些语法特殊处理。语法糖虽然不会带来实质性的改进，但是在提高代码可读性，提高语法严谨性，减少编码错误机会上确实做出了很大贡献。 集合类常用方法： size（） isEmpty（） contains（） clear（） toArray（）","link":"/2019/11/20/IT/java/%E3%80%90Java%E3%80%91%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88/"},{"title":"【Java】类与对象","text":"类与对象概述Java的设计体现了面向对象的思想，一切皆为对象（除了基本数据类型），面向对象包括三个特性： 封装 继承 多态 类就像是一个模板，而对象就是根据这个“模板”制作出的产品。 类包括4种访问控制权限，如下： 关键字 说明 private 仅对本类可见 default（默认省略） 对本包可见 protected 对本包和所有子类可见 public 对所有类可见 对象和对象变量1234public static void main(String[] args) { //a是一个对象变量，而new Date()则创建了一个对象 Date a = new Date();} 其中，对象变量获取的是对象的引用。 static关键字首先要理解“静态域”的概念，静态域是伴随于类存在的，和对象无关，也就是说，当已经存在一个类时，无需声明其对象，就已经拥有了静态域内的所有资源。并且，每一个类有且仅有一个静态域，且静态域是封闭的，既静态域中的方法，不能调用非静态域的属性。 静态变量和静态常量（类数据）静态变量不常用用，但静态常量却用的比较多，比如：Math.PI，一般静态常量用final关键字修饰，为了保证其不被修改 使用类数据的两种方法： 通过类去定位数据：Math.PI(推荐) 通过对象去定位数据：Math math=new Math()；math.PI 静态方法（类方法）静态方法，是静态域中的内容，不能调用非静态域中的属性，但可以访问自身静态域中的属性 在下面两种情况下，可能使用静态方法： 一个方法不需要访问对象的状态 一个方法只需要访问其静态域 通过this指针了解staticstatic方法就是没有this的方法，而普通的方法是由对象调用的，所以有 this 抽象类 抽象类是普通类和接口的折中，拥有普通类和接口两者的特性！！！！ 抽象类可以包括抽象方法和非抽象方法 普通类中的方法就是非抽象方法，这种方法不强制要求其子类去实现什么，继承后即可使用。 而接口中的方法则为抽象方法，必须由实现接口的类去完成具体功能的实现。 一个类只能继承一个抽象类，而一个类却可以实现多个接口 普通类的单继承的 而接口是多实现的 从上述特点可以看出：抽象类是普通类和接口的折中 从另一个角度理解：抽象类要求其子类必须实现某种接口 Java中常用的类Date Date类采用的是UTC时间 打印出的格式为：Tue Aug 20 15:25:05 CST 2019 同时包含了年月日时分秒 LocalDate 采用的是当地的标准时间，例如在中国，采用的是公历 打印出来的格式为：2019-08-20 只包含年月日 创建对象不是使用构造器，而使用静态的.of()方法 1234public static void main(String[] args) { LocalDate a = LocalDate.of(2011, 8, 20); System.out.println(a.getYear()); } LocalDate可以自定义日期 还可以计算多少天之后的日期，可用于会员日期的计算 12345public static void main(String[] args) { LocalDate a = LocalDate.of(2019, 8, 20); LocalDate b=a.plusDays(1000); System.out.println(b); } LocalTime和LocalDateTime基本使用方法可以参考LocalDate Math Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。 Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。 Random可以进行随机生成，其实是伪随机（以时间为种子） 大数值类当基本的整数和浮点数的精度或大小范围不够用时，可以使用BigInteger和BigDecimal（可以处理任意长度数值） 声明变量比较特殊 不能使用熟悉的运算符去运算此类 123456789public static void main(String[] args) { //声明大数值类型 BigInteger a = BigInteger.valueOf(100); BigInteger b = BigInteger.valueOf(1000); //相当于a+b BigInteger c = a.add(b); //相当于a*b BigInteger d = a.multiply(b); } 包装类 包装类和基本数据类型之间可以自动装箱和拆箱 用包装类做相等比较的时候，要使用equals，原因是“==”比较的是包装类声明的对象的引用 包装类对象值不能改变，并且包装类都用final修饰，不能被继承 8中基本数据类型都有对应的包装类，这里用int的包装类，Integer为例： Integer.parseInt(“1024”); Integer.valueOf(“1024”).intValue(); 这两个返回值都为int型 parseInt（）：是Integer中的静态方法，将数据转换为int型（可以由函数名称看出） Integer.valueOf（）：可以将数据转换为Integer类型 intValue是Integer对象的内置方法，用与将Integer类型转换为int型（但是其实由自动装箱和拆箱）","link":"/2019/11/18/IT/java/%E3%80%90Java%E3%80%91%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"title":"【计算机网络】物理层","text":"物理层简介物理层之间的传输单位是比特（bit） 物理层考虑的是，怎样才能在连接各种计算机的传输媒体上传输数据比特流，描述了传输媒体接口的特性： 机器特性：接口的尺寸，形状，引脚数等。 电气特性：电缆上各条线的电压范围 功能特性：某条线上的电压意义 过程特性：对于不同功能的各种可能事件的出现顺序 数据通信基础知识一，信道的分类 单向通信（单工）：只能向一个方向发送信号，例如：广播，集线器 双向交替通信（半双工）：可以双向发送，但是不能同时发送 双向同时通信（全双工）：可以双向并且同时发送，如交换机 二，常用的数字信号编码方式 不归零制：正电平代表1，负电平代表0 归零制编码：正脉冲代表1，负脉冲代表0 曼彻斯特编码：位周期中心向上跳变代表0，位周期中心向下跳变表示1 差分曼彻斯特：在每一位的中心处始终都有跳变。位开始边界有跳变代表0，位开始边界没有跳变代表1 物理层下面的传输媒体一，引导型传输媒体（沿着媒介传播） 双绞线 同轴电缆 光缆 二，非引导型传输媒体（空间自由传播） 波 信道复用技术 使用信道复用技术可以节约信道，经济实惠 频分复用不同频率代表着不同的发送者 时分复用把帧分成多个段，不同段代表着不同的发送者 码分复用（码分多址）每一个比特时间在划分为m个短的间隔，称为码片。各个用户使用经过特殊挑选的不同码片序列，并且相互正交（积为0），因此个用户之间不会产生干扰。 例题：","link":"/2019/11/20/IT/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%89%A9%E7%90%86%E5%B1%82/"},{"title":"【Java】泛型","text":"泛型泛型的意义没有约束的自由，称不上为自由，这也正是泛型存在的意义，他一方面限制了代码的自由，一方面又使得代码变得自由。 限制了自由这里说的限制了自由，其实是为了避免代码出错，变得难以管理，这里举个例子： 既然我们已经有了全能的Object类，为什么还需要泛型呢？ 最初没有泛型的时候，Arraylist是使用Object类来实现的，但是这样做，存在两个问题： 当获取一个值时，必须进行强制的类型转换 1String name=(String) arrayList.get(0); 没错类型检查，一个Arraylist中可以添加任意对象 但是当引入了泛型之后，ArrayList变量在声明时变决定了类型，所以这样就解决了上述两个问题。 让代码变得自由这一点体现在提高了代码的复用率，例如： 12345678910@Data@NoArgsConstructor@AllArgsConstructorpublic class Pair&lt;T&gt; { private T first; private T seconde; public void test(){ Pair&lt;String&gt; pair = new Pair(); }} 泛型的原理其实泛型的底层实现，靠的是使用的时Object类，运行时类型参数会被擦掉。例如，无论你声明的的是List&lt;String&gt;，还是List&lt;Integer&gt;或者原生类List，容器实际类型都是List&lt;Object&gt;。 所以泛型实际上都是狼外婆，它看上去像外婆，但实际上是大灰狼。 泛型实现的原理是类型的擦除，所以不能使用基本数据类型当作泛型的类型 泛型实现的原理是类型的擦除，所以不能将泛型和数组同时使用 Tips 常用的缩写 E：表示元素集合 K和V：表示关键字类型和值类型 T：表示任意类型(常用) 不仅仅是类上声明泛型，在方法上也可以声明泛型。 泛型的类型可以进行条件限定： Class类是泛型类","link":"/2019/11/19/IT/java/%E3%80%90Java%E3%80%91%E6%B3%9B%E5%9E%8B/"},{"title":"【Java】继承与接口","text":"枚举什么是枚举Emum是在Java5中引入的新特性，从那开始，它被广泛的用在不同的Java应用中。Enum是一个Java的关键字，用于表示一个固定的常用值。例如，每周的天数，每年的月数等。Enum是一种类型，就像Class和Interface可以用于定义一系列的Enum常量 枚举的特点 Enum常量隐式的加上了static和final，一旦被创建就无法修改，所以是线程安全的 Enum提供了是类型安全的(type-safe) Enum隐式的加上了values()方法，返回一个数组包含所有的Enum常量 两个Enum常量可以使用 ==或equals()方法比较 Enum可以用在switch语句中，就像int，String。 Enum有自己的名称空间 Enum可以实现Java接口 可以在Enum中定义构造器 所有的enums隐式的extend了java.lang.Enum类，因为一个类只能extend一个父亲，所以enum不能extend其它的类。但是Enum可以实现许多接口。 枚举的使用12345678910111213// 外部声明Enumenum Color { RED,GREEN,BLUE;}public class Test{ public static void main(String[] args) { Color c1 = Color.RED; //输出RED System.out.println(c1); }} 枚举的原理12345678910111213141516171819202122//案例代码enum AccountType implements Serializable,Cloneable{ SAVING, FIXED, CURRENT; private AccountType() { System.out.println(\"It is a account type\"); }}class Main{ public static void main(String[]args) { System.out.println(AccountType.FIXED); }}//输出结果It is a account typeIt is a account typeIt is a account typeFIXED 枚举类在后台实现时，实际上是转化为一个继承了java.lang.Enum类的实体类，原先的枚举类型变成对应的实体类型，上例中AccountType变成了个class AccountType，并且会生成一个新的构造函数，若原来有构造函数，则在此基础上添加两个参数，生成新的构造函数，如上例子中： 123private AccountType(){ System.out.println(“It is a account type”); } 会变成： 1234private AccountType(String s, int i){ super(s,i); System.out.println(“It is a account type”); } 而在这个类中，会添加若干字段来代表具体的枚举类型： 123public static final AccountType SAVING;public static final AccountType FIXED;public static final AccountType CURRENT; 而且还会添加一段static代码段： 12345static{ SAVING = new AccountType(\"SAVING\", 0); CURRENT = new AccountType(\"CURRENT\", 0); $VALUES = new AccountType[]{ SAVING, FIXED, CURRENT }} 以此来初始化枚举中的每个具体类型。（并将所有具体类型放到一个$VALUE数组中，以便用序号访问具体类型） 在初始化过程中new AccountType构造函数被调用了三次，所以Enum中定义的构造函数中的打印代码被执行了3遍。 异常异常的结构分类 所有的异常都是继承了Thowable。 Error：是运行时系统错误，或者资源耗尽错误等，是没办法解决的，这时应该通告用户，并尽力使程序安全终止 Exception：又分为两种 RuntimeException：当出现这种异常时，一定时程序本身存在问题，可能是错误的类型转换，数组越界，空指针等等 非RuntimeException：可能是I/O异常，文件不存在，类不存在等等 受检异常和非受检异常非受检异常指的是java.lang.RuntimeException和java.lang.Error类及其子类，所有其他的异常类都称为受检异常。 那么什么是受检异常和非受检异常呢？ 受检异常的特点在于它强制要求开发人员在代码中进行显式的声明和捕获，否则就会产生编译错误。这种限制从好的方面来说，可以防止开发人员意外地忽略某些出错的情况，因为编译器不允许出现未被处理的受检异常 非受检异常的特点是，如果不捕获异常，不会产生编译错误，异常会在运行时刻才被抛出。 异常的用法throw和throws关键字Throw用于抛出异常对象，后面跟的时异常对象。是语句抛出一个异常。多用在函数内。 语法：throw(异常对象) ​ throw e; Throws是方法可能抛出异常的声明（用在声明方法时，表示该方法可能要抛出异常） 语法：修饰符 返回值类型 方法名 参数类型 throws异常类 ​ public void test throws Exception1,Exception2(){} finally关键字 finally声明的代码段中，即使代码已经进入了返回值阶段，也一定会在程序程序末尾执行 1234567891011121314151617public class Main { public static int getNumber() { try { System.out.println(\"try\"); return 1; } catch (Exception e) { System.out.println(e); } finally { return -1; } } public static void main(String[] args) { //输出结果-1 System.out.println(getNumber()); }} 正则表达式java正则表达式的实现，是利用了java.util.regex包下的Pattern类与Matcher类 Pattern类（制定匹配规则） 创建pattern对象： 12Pattern p=Pattern.compile(\"\\\\w+\"); p.pattern();//返回 \\w+ 根据正则分隔字符串：返回一个String[] 123Pattern p=Pattern.compile(\"\\\\d+\"); String[] str=p.split(\"我的QQ是:456456我的电话是:0532214我的邮箱是:aaa@aaa.com\"); //结果:str[0]=\"我的QQ是:\" str[1]=\"我的电话是:\" str[2]=\"我的邮箱是:aaa@aaa.com\" Pattern.matcher(String regex,CharSequence input)是一个静态方法,用于快速匹配字符串,该方法适合用于只匹配一次,且匹配全部字符串 123Pattern.matches(\"\\\\d+\",\"2223\");//返回true Pattern.matches(\"\\\\d+\",\"2223aa\");//返回false,需要匹配到所有字符串才能返回true,这里aa不能匹配到 Pattern.matches(\"\\\\d+\",\"22bb23\");//返回false,需要匹配到所有字符串才能返回true,这里bb不能匹配到 通过pattern返回matcher对象，Matcher类的构造方法也是私有的,不能随意创建,只能通过Pattern.matcher(CharSequence input)方法得到该类的实例. 123Pattern p=Pattern.compile(\"\\\\d+\"); Matcher m=p.matcher(\"22bb23\"); m.pattern();//返回p 也就是返回该Matcher对象是由哪个Pattern对象的创建的 Matcher类（查看匹配情况） 查看匹配情况 12345Pattern p=Pattern.compile(\"\\\\d+\"); Matcher m=p.matcher(\"22bb23\"); m.matches();//返回false,因为bb不能被\\d+匹配,导致整个字符串匹配未成功. Matcher m2=p.matcher(\"2223\"); m2.matches();//返回true,因为\\d+匹配到了整个字符串 lookingAt()对前面的字符串进行匹配,只有匹配到的字符串在最前面才返回true 12345Pattern p=Pattern.compile(\"\\\\d+\"); Matcher m=p.matcher(\"22bb23\"); m.lookingAt();//返回true,因为\\d+匹配到了前面的22 Matcher m2=p.matcher(\"aa2223\"); m2.lookingAt();//返回false,因为\\d+不能匹配前面的aa find()对字符串进行匹配,匹配到的字符串可以在任何位置 123456789Pattern p=Pattern.compile(\"\\\\d+\"); Matcher m=p.matcher(\"22bb23\"); m.find();//返回true Matcher m2=p.matcher(\"aa2223\"); m2.find();//返回true Matcher m3=p.matcher(\"aa2223bb\"); m3.find();//返回true Matcher m4=p.matcher(\"aabb\"); m4.find();//返回false 返回匹配的位置 123456789101112131415161718Pattern p=Pattern.compile(\"\\\\d+\"); Matcher m=p.matcher(\"aaa2223bb\"); m.find();//匹配2223 m.start();//返回3 m.end();//返回7,返回的是2223后的索引号 m.group();//返回2223 Mathcer m2=m.matcher(\"2223bb\"); m.lookingAt(); //匹配2223 m.start(); //返回0,由于lookingAt()只能匹配前面的字符串,所以当使用lookingAt()匹配时,start()方法总是返回0 m.end(); //返回4 m.group(); //返回2223 Matcher m3=m.matcher(\"2223bb\"); m.matches(); //匹配整个字符串 m.start(); //返回0,原因相信大家也清楚了 m.end(); //返回6,原因相信大家也清楚了,因为matches()需要匹配所有字符串 m.group(); //返回2223bb groupCount()用于返回有多少组 12345678910Pattern p=Pattern.compile(\"([a-z]+)(\\\\d+)\"); Matcher m=p.matcher(\"aaa2223bb\"); m.find(); //匹配aaa2223 m.groupCount(); //返回2,因为有2组 m.start(1); //返回0 返回第一组匹配到的子字符串在字符串中的索引号 m.start(2); //返回3 m.end(1); //返回3 返回第一组匹配到的子字符串的最后一个字符在字符串中的索引位置. m.end(2); //返回7 m.group(1); //返回aaa,返回第一组匹配到的子字符串 m.group(2); //返回2223,返回第二组匹配到的子字符串","link":"/2019/11/19/IT/java/%E3%80%90Java%E3%80%91%E6%9E%9A%E4%B8%BE%EF%BC%8C%E5%BC%82%E5%B8%B8%EF%BC%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"【操作系统】线程管理","text":"线程的管理为什么需要线程管理线程管理是对某个程序中全部线程的管理工作，当不同进程对同一资源进行操作时，可能会出现以下问题： 安全性问题 活跃性问题 性能问题 为了使程序可以健壮，稳定，高效的运行，我们需要对线程进行管理。 安全性问题那么线程的安全性问题是什么？对于程序来讲，在运行时发生错误就是不安全的。所以，对于线程来讲，安全性问题即运行结果的“正确性问题”。 最常见的例子就是： 1count++； 这个操作其实分为三步： 首先获取count的值； 将count的值+1； 将+1后的结果赋值给count； 当两个线程对同一count变量执行该操作时，由于执行顺序有很多种，所以会产生不同的结果，也就可能会产生错误的结果，这就是线程的安全性问题。 活跃性问题什么是活跃性问题？当一个线程由于某些原因一直没有被执行，或者所分到的时间片非常少，那么这个线程就存在着活跃性问题。 常见的活跃性问题包括：死锁，饥饿，活锁。 死锁 线程A在等待B持有的某种资源（这里是锁），而线程B在等待A持有的某种资源，在没有获得自己想要的资源之前，线程A和线程B都不会主动的释放自己所持有的资源，于是就陷入了“死锁”； 形象一点来讲，就像是幼儿园的两个小朋友吵架了，两个小朋友心理都在想“哼！╭(╯^╰)╮如果你不道歉，我就不道歉”，于是局面就一直僵持着。 活锁活锁概念：独木桥两个人互相让路。 在计算机中活锁的情况不太常见。这里就不展开讨论。 饥饿人的饥饿是因为没有食物吃，而线程的饥饿时因为没有CPU时间片使用，产生这种情况的原因可能是： 线程的优先级太低 CPU的调度算法存在问题，或者不适合该程序 性能问题正如字面意义，如果存在性能问题，说明服务时间过长，相应不灵敏，吞吐量低等。 在线程方面出现这类问题的原因通常是“滥用锁”； 引入多线程的目的就是因为程序中的多种任务可以并行执行（参考单核多线程的CPU），但由于频繁加锁，或者锁的细粒度很大，会导致程序很长一部分时间都处于单线程状态，自然会产生性能问题。 如何解决上述问题有两种经典有效的办法解决上述问题，“正确的”使用PV操作或管程。 对于安全性问题，产生的原因是不同线程对共享变量的操作时机不同，所以我们只需要保证某一时刻只有一个线程操作共享变量即可，即线程互斥； 对于活跃性问题，往往是由于某个线程不能得到他需要的某个资源，所以我们要做好“线程间的同步”工作，即线程同步； 对于性能问题，往往是由于“锁的滥用”，所以我们要尽量使用小粒度的锁。 PV操作和管程PV操作一，信号量 信号量：表示一种资源能否被使用。其数据结构表示如下 123456semaphore{ //正数时（包括0）表示可使用的资源个数，负数时，表示等待进程的个数 int value; //进程的阻塞队列 PCB* pointer;} 注意，信号量只能只能三个操作 初始化 被P操作 被V操作 信号的设置，往往是针对操作的 二，P原语 P代表进程申请使用资源，申请后，资源的信号量value值-1 如果此时value&lt;0，则将此进程插入到阻塞队列中 如果value在-1后≥0，则执行该进程 三，V原语 V代表进程归还（释放）资源，释放后，value值+1 如果+1后，value≤0，则说明原来是小于0的，说明阻塞队列中有等待资源的进程，+1代表释放一个资源，所以要执行一个阻塞队列中的进程 如果+1后，value＞0，则说明没有被阻塞的进程，只是归还一个待使用的资源而已 管程 管程可以看做是一个盒子，他把共享变量和对共享变量的操作封装到一起，并且盒子(管程)中只有一个位置，即同一时刻只允许一个进程进入管程。 这里可能看起来很抽象，具体的使用方法请参考下文。 进程互斥什么是进程互斥？进程互斥就是不允许两个进程同时进入临界区（共享内存），去操作临界资源(共享资源)。 使用PV操作解决互斥问题 定义信号量mutex，由于是实现互斥，所以初始值为1（表示只有一个资源可以被使用） 使用P操作检测mutex 使用V操作检测mutex 程序的实现大致如下： 12345678910semaphore mutex;mutex.value=1;process pi{......P(mutex);临界区代码......V(mutex);.......} 使用管程解决互斥问题 如上图所示，由于管程中的预留位置为1，所以同一时刻只能有一个线程进入管程。那么管程是怎么保证只有一个的呢？ 因为管程使用了 入口等待队列 。要想进入管程就要先进入队列排队。 这样就保证了同一时刻只有一个线程操作共享变量，解决了线程互斥的问题。 进程同步什么是进程的同步？同步表示不同进程种相互制约的执行关系。即要想执行某项任务，必须满足某个前提条件。 使用PV操作解决同步问题同步的信号量往往是针对操作本身的（也就是说该操作是否可以被执行） 而互斥的信号量往往代表一种资源是否可以被使用 最常见的同步例子：生产者-消费者，缓冲区大小为n，消费者如果想要进行消费，那么商品队列中一定要有商品，具体实现如下： 使用管程解决同步问题 首先假设消费者线程先进入管程中，要进行消费执行decrease操作的条件变量是full=true，但是当前条件不满足，于是此线程被加入到对应条件变量的等待队列中 此时生产者线程进入，发现empty=true，于是执行increase操作 在执行increase后，条件变量full=true，于是释放相应队列中的线程 同步和互斥结合生产者-消费者（这里的缓冲区大小要求为K[k大于1]） 这里的同步指的是： 消费者在消费前，队列中要有产品； 生产者在生产前，产品队列不满； 互斥指的是对临界资源的互斥操作，既同一时刻只能有一个线程对产品队列进行操作","link":"/2019/11/22/IT/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"title":"【计算机网络】概述","text":"什么是计算机网络计算机网络主要是由一些通用的，可编程的硬件互相连接。这些硬件能够用来传输多种不同类型数据。计算机网络所连接的硬件不只包含计算机，智能手机也同样适用。 一些网络的概念互联网(internet)字母i一定要小写！它的意思是“网络的网络”，凡是由能彼此通信的设备组成的网络就叫互联网，即使仅有两台机器（计算机、手机等），不论用何种技术使其彼此通信，都叫互联网。 因特网(Internet)因特网是基于TCP/IP协议实现的，TCP/IP协议由很多协议组成，不同类型的协议又被放在不同的层。其中，位于应用层的协议就有很多，比如FTP、SMTP、HTTP。所以，因特网提供的服务一般包括有：www（万维网）服务、电子邮件服务（outlook）、远程登录（QQ）服务、文件传输（FTP）服务、网络电话等等。 万维网(World Wide Web)只要应用层使用的是HTTP协议，就称为万维网(World Wide Web)。 总结互联网包含因特网，因特网包含万维网，要求越来越严苛。 计算机网络的分类一，按作用范围分类 广域网WAN：作用范围通常为几十到几千公里，并且一般采用的都是高速链路 城域网MAN：通常覆盖一个城市，用来将多个局域网互联 局域网LAN：地域上看局域网通常是用在一座建筑物或某一部门使用 二，按使用者进行分类 公用网：电信公司等的大型网络服务。 专用网：专门为某个部门服务的网络，例如军队，铁路，银行等。 性能指标速率、带宽、吞吐量速率比特（bit）是计算机中数据量的单位，意思是一个“二进制数字”，就是0或1。速率指的是连接在计算机网络上的主机在数字信道上传送数据的速率，其单位是bit/s（比特每秒，或b/s，bps[bit per second]），当数据率较高时，就可以用kbit/s、Mbit/s、Gbit/s或Tbit/s。 带宽表示网络的通信线路传送数据的能力，即单位时间内，从网络一点到另一点所能通过的最高数据率，带宽越宽，其所能传输的“最高数据率”也越高，速率和带宽的关系类似于额定功率和最大功率。单位：b/s 、bps、Kbps、Mbps 吞吐量单位时间内，网络中传递的实际的数据量，是一种速率单位。吞吐量受网络的带宽或网络的额定速率的限制。 对100Mb/s的以太网，其典型的吞吐量可能只有70Mb/s。 三者的联系速率是额定或标称的，但是实际传输时，其实不稳定的，吞吐量就是取实际传输时的平均值。而带宽是理论上最大的速度。 假设你从学校骑电动车回家，这条公路限速80km/h，这就可以理解成“带宽”，也就是“最高传输速率”。所骑电动车厂家宣称最高时速30km/h，这可以理解成“速率”，也就是“额定速率或标称速率”。但是你不可能全程以30km/h速度行驶，可能会碰到红灯或者堵车，这时你的速度就会放慢了，这条路的长度除以你行驶时间所得平均行驶速度，就可以理解成“吞吐量”。 其他指标时延 处理时延：主机或路由器在接收分组时需要花费一定的时间进行处理 排队时延：分组在经过网络传输时，要经过许多的路由器。但分组在进入路由器后要先在输入队列中排队等待处理 发送时延：发送时延是主机或路由器发送数据帧所需要的时间，即从数据帧的第一个比特算起，到最后一个比特发送完毕的所需时间。 传播时延：传播时延是电磁波在信道中传播一定距离需要花费的时间 时延带宽积时延带宽积=传播时延×带宽。链路像一条空心圆柱形管道，时延带宽积就表示这个管道的体积，表示这样的链路可以容纳多少个比特。 往返时间RTT表示从发送方发送数据开始，到发送方接收到来自接收方的确认，总共经历的时间。 利用率 信道利用率：某信道有百分之几的时间是被利用的（有数据通过），并非越高越好。 网络利用率：全网络的信道利用率的加权平均值。 层次的划分 OSI包含了七层协议，虽然理论完整，但是既复杂，又不实用。 TCP/IP的四层协议，体系简单，得到了广泛应用。 为了学习我们折中，采用”五层协议“，如图 物理层考虑的是怎样在传输介质上传输数据比特流。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 说白了就是尽量传输想表达的原生信息。 数据链路层网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为相邻结点之间提供服务。数据链路层把网络层传来的分组封装成帧。 说白了就是对数据进行校验，留下正确的信息，丢掉错误的信息。通过MAC地址，完成了数据在同一网络中的传输。 网络层通过ip，路由器等，完成了不同网络之间主机的通信。 运输层提供的是不同主机的进程间的通用数据传输服务。 运输层包括两种协议： 传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；TCP 主要提供完整性服务。 用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。UDP 主要提供及时性服务。 应用层为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。 数据在各层之间的传递 本质就是数据从AP1开始，不断被包装，最后通过信号传递到主机2，再不断拆包装，最终还原为原始的数据。 各层协议结构","link":"/2019/11/20/IT/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E6%A6%82%E8%BF%B0/"},{"title":"【计算机网络】数据链路层","text":"数据链路层简介数据链路层的作用 将网络层的数据进行封装，并保证数据在物理层之间可以准确的传输。注意：这里的准确传输指的是所接受的数据一定是正确的，而出错的数据，直接丢弃。通俗点将，就是保质不保量 基本概念链路：指的是物理线路，例如：双绞线，光纤等 数据链路：指的是逻辑线路，这里是一些必要的通信协议，保证了数据传输的可靠性 帧：把网路层数据打成的包，是数据链路层之间传输的基本数据单元 数据链路层最大传送单元（MTU）：指的是数据链路层中，一个帧中所能承载的最大的数据部分的长度 三个基本问题数据链路层存在着很多种协议，但是所有协议都解决了三个基本问题：封装成帧，透明传输，差错校验。 封装成帧 将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 透明传输 这里的透明传输并不是说让数据变得“透明”，而是让帧的首部和尾部变得“透明”。 帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 差错检测检测传输的数据是否有错误，CRC是数据链路层广泛使用的一种检错技术。 循环冗余检验CRC得到FCS，可以通过FCS判断是否出错；如果出错，并不能改正，而是直接丢掉。 点对点链路的PPP协议对于点对点的链路，应用最广泛地就是PPP协议 PPP协议的帧格式 F字段：标志着帧的开始和结束，默认为0X7E A字段：预留字段，默认为FF C字段：预留字段，默认为03 协议： 当协议字段为0x0021时，表示信息部分为IP数据报 字段为0xc021时，表示信息部分为LCP数据 0x8021表示为网络层的控制数据 FCS：是使用CRC的帧检验序列 PPP协议实现透明传输为了避免信息部分也出现7E，FF，03等字段，PPP协议提供了两种解决方案 字节填充 当信息字段中出现0x7E时，将每一个0x7E字节转变成2字节序列（0x7D，0x5E） 若信息字段中出现一个0x7D的字节，则将其转变成2字节序列（0x7D，0x5D） 若信息字段中出现ASCII码的控制字符(即数值小于0X20的字符)，则该字符前面需要加入一个0x7D字节，同时将该字符的编码加以改变(+20)。例如，出现0x03，就要把它转为2字节序列(0x7D，0x23) 这里举例说明：如果一个帧的信息部分，想要传递0x7E，那么PPP协议会将其变为0x7D0x5E进行传输。 零比特填充有些时候，数据链路层传输的不是字符，而是比特位（bit），这时就要使用零比特填充法。 原理类似，都是为了避免特殊字段被信息部分影响。 7E用二进制表示，是0111 1110，这里以7E为例，其他特殊标识类似 具体做法为：在发送端扫描整个信息字段，当有5个1连续出现时，立即填入一个0，保证信息字段中不会出现6个连续1。 广播链路的CSMA/CD协议广播链路是一种总线的结构，也就是说，当一台计算机发送数据时，总线上的所有计算机都能检测到这个数据。 但是，有时候我们并不想让所有计算机都接受，而是想指明特定计算机发送数据。为了在总线上实现一对一的通信，我们可以利用MAC地址来标识不同的计算机。 广播链路上一对一通信的原理我们理清楚了，但是还有一个问题，怎么保证链路总线上只有一种信号在传输？ 也许你会想到利用各种编码方式，使信道可以复用，但是这些编码有一个缺点，那就是所占的频带宽度比原始的基带信号增加了一倍。 所以我们可以换一种思路，如何保证同一时刻只有一个信号正在传输？这样正是CSMA/CD协议解决的主要问题 CSMA/CD协议的要点如下： 多点接入 载波监听 碰撞检测","link":"/2019/11/20/IT/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"title":"【计算机网络】网络层","text":"网络层简介虚拟互联网 在介绍网络层之前，我们需要了解一下，什么是虚拟互联网？ 虚拟互联网，简单的来说，就是“网络的网络”，他利用路由器将不同的网络连接起来，形成了一个大的网络。 网络层的任务介绍完什么是虚拟互联网，就能理解网络层的任务：保证了相同或不同网络中的计算机之间的连接与通信。 IP协议IP的简介IP存在的目的，是为了分辨不用网络中的不同主机，我们可以使用不同的IP来标明不同的主机。 IP地址：32位（四个字节）二进制组成（IPV4） IP分类和特殊IP A类地址，前八位，1~126 B类地址，前八位，128~191 C类地址，前八位，192~223 特殊IP： 网络地址：网络号+全0，表示这个网络 广播地址：网络号+全1，表示这个网络的广播地址 环回地址：习惯上采用127.0.0.1作为环回地址，命名为localhost。 路由地址： 192.168.1.1属于保留IP，专门用于路由器设置 虚拟互联网的总体结构 ARP协议ARP协议可以将目的主机的IP地址解析为MAC地址。 所谓地址解析（address resolution）就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。 另外，当发送主机和目的主机不在同一个局域网中时，可能不知道对方的MAC地址，并且两者也不能直接通信，必须经过路由转发才可以。所以此时，发送主机通过ARP协议获得的将不是目的主机的真实MAC地址，而是一台可以通往局域网外的路由器的MAC地址。 IP数据报 版本号：占用4位二进制数，表示该IP数据报使用的IP协议版本。目前Internet中使用的主要是TCP/IP协议族中版本号为4的IP协议。 首部长度：占用4位二进制位，此域指出整个报头的长度（包括选项），该长度是以32位二进制数为一个计数单位的，接收端通过此域可以计算出报头在何处结束及从何处开始读数据。普通IP数据报（没有任何选项）该字段的值是5（即20个字节的长度）。 总长度：占用16位二进制位，总长度字段是指整个IP数据报的长度（报头区+数据区），以字节为单位。利用头部长度字段和总长度字段就可以计算出IP数据报中数据内容的起始位置和长度。 标识：当传输数据过大时，就会进行数据的分片，会形成很多个IP数据报，如果IP数据报拥有相同的标识，那么说明这些IP数据报是同一个数据分片而来的。 标志：共站3位，第一位保留，目前只有后两位有意义 第二位MF：0表示这个是最后一片，1表示还有分片 第三位DF：0表示允许分片 片偏移：用于表示当前片数据在原数据中的相对偏移位置 IP层的数据报转发流程待完善 子网和超网什么是子网？我们平常用的IP可以分为A类，B类，C类等，这三类主机号位数是一定的，比如： A类IP的网络号是8位，主机号是24位 B类IP的网络号是16位，主机号是16位 C类IP的网络号是24位，主机号是8位 网络号的位数决定了网络的个数；而主机号的位数，决定了网络中主机的个数； 但是这些ABC类IP的位数也只是人为规定的，如果我们把这些较大的网络段，分为较小的网络段，那么这些就是子网，例如：我们可以把0010x分为00100和00101。 为什么要分为子网 A类拥有超过65535台主机 B类拥有介于255~65535台主机 C类拥有小于255台主机 这种分类却又几个很明显的缺陷： IP地址空间的利用率有时候很低，地址浪费大：只有两、三台主机的网络，也至少要一个C类IP地址，A、B类浪费更严重，少有达上万台主机的大型IP网络。 不够灵活：企业有很多部门，每个部门可能需要各自独立的网络，这怎么办呢？再申请网络？可是人数又不多，怎么办呢？划分子网刚好可以解决这个问题，而且便于管理。 如何划分子网划分子网时，需要利用子网掩码 子网掩码是一个应用于TCP/IP网络的32位二进制值，1代表网络号，0代表主机号。它可以屏蔽掉ip地址中的一部分，从而分离出ip地址中的网络部分与主机部分，基于子网掩码，管理员可以将网络进一步划分为若干子网。 例如常见的255.255.0.0转换为二进制就是1111 1111.1111 1111.0000 0000.0000 0000，这就是B类网的默认子网掩码。 路由选择协议RIP协议待完成","link":"/2019/11/20/IT/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"title":"【操作系统】处理器调度","text":"处理器调度什么是处理器调度 我们知道现如今的CPU往往是多核多线程的，拿作者的电脑举例子：总共4个核心，每个核心可以处理4个线程。也就是说同时能提供16个线程的并行处理。 但是如今的系统非常复杂，再加上各种大型软件，线程需要被创建，执行，销毁等，所需线程数远大于16，所以就需要cpu在不同的程序线程中来回切换，这就称为处理器调度。 处理器调度层次 长程调度长程调度发生在新进程的创建中，他决定了一个进程能否被创建，或者创建后是否被置成就绪态，来参加处理器资源的竞争。 中程调度主要负责内存和外存之间的进程对换，解决内存紧张的问题。 短程调度（重点）短程调度决定哪一个就绪的线程去占用CPU资源进行执行。 短程调度功能： 保护当前正在执行进程的现场 根据算法策略从就绪进程中选择一个，将CPU分配给他 恢复被调度到的进程的原来现场，从上次放弃的地方继续执行 短程调度的方式： 剥夺式，抢占式：优先级原则，短进程原则，时间片原则 非剥夺式，非抢占式：这种方式下，除非当前正在执行的线程主动让出CPU，否则其他线程没有机会执行 短程调度算法短程调度决定哪一个就绪的线程去占用CPU资源进行执行。为了方便理解思想，我们讨论“单核单线程”的情况。 先来先服务调度正如名字，“先来先服务”。先进入队列的线程，优先获得CPU的使用权。 缺点：不适合实时操作系统 时间片轮转法系统将所有的就绪进程按顺序排成一个队列，每次调度 时，按照顺序把 CPU 分配给全部线程，并令其执行相同的时间片。 缺点：容易频繁切换上下文，CPU有效时间比例降低 最短进程优先调度所需要CPU时间最短的线程优先获取CPU的使用权。 缺点：可能会产生饥饿情况 优先级调度根据线程的优先级分配CPU。 缺点：难以确定各个线程的优先级。 多级反馈队列轮换法 上述各种调度方法都有一定的缺陷和偏向方面。 多级反馈队列调度算法是一种根据先来先服务原则给就绪队列排序，为就绪队列赋予不同的优先级数，不同的时间片，按照优先级抢占CPU的调度算法。 是一种相对公平，且高效的调度算法。","link":"/2019/11/22/IT/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/"},{"title":"【操作系统】存储器管理","text":"存储器存储器多级存储结构 外部存储器：用于存储不立即使用的数据和程序 主存储器：用于存储一个正在运行的程序 高速缓冲存储器：用于存储CPU处理时的数据 功能：可以使数据传输更加平滑，节约资源，提高硬件利用率。 存取器空间的分类主存储器空间一般分为系统区和用户区： 系统区：主要存放操作系统常驻内存部分，和一些系统软件常驻主存部分以及相关系统数据 用户区：主要存放用户程序和数据 虚拟存储技术当我们的内存只有1G，而某个程序运行需要2G时，我们应该怎么运行这个程序呢？ 解决办法是就是虚拟存储技术。 虚拟存储技术采用逻辑地址，内存中只存放程序当前所需数据，当有所需数据不在内存中时（这种情况叫作中断），会去磁盘中寻找相应数据放入主存中。 例如，内存1G，程序运行需要2G内存，但是在运行时，处于计算状态的只有100M，所以我们只需要将这100M放入内存即可，当需要其他数据时，再从磁盘中取出放入内存中。 作业，程序，进程，线程一个作业通常包括程序、数据和操作说明书3部分。每一个进程由PCB、程序和数据集合组成。这说明程序是进程的一部分，是进程的实体。因此，一个作业可划分为若干个进程来完成，而每一个进程有其实体——程序和数据集合。 单道程序和多道程序多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中共享着计算机系统资源。 与之相对应的是单道程序，即在计算机内存中同一时刻只允许一个的程序运行。 存储器的主要任务存储器的主要任务如下： 使多道程序的并发能在不受干扰的环境中运行 提高存储器利用率 实现虚拟存储技术，逻辑上扩充主存空间，使大程序能在小主存中运行 方便用户使用存储器，用户无需考虑存储器的分配，回收和保护等工作 存储分配的形式存储分配要解决的问题是，多道程序之间如何共享主存的存储空间。 直接存储分配方式（不推荐） 通过实际物理存储地址直接操作内存 要求知道存储器的可用空间有哪些，并且要知道其他程序已经应用了哪些存储空间 使用起来很不方便，要求程序编写人员要了解硬件 静态存储分配（不推荐） 采用逻辑地址 程序装入内存后，只有运行完毕，才会释放该空间，利用率较低 动态存储分配（推荐） 只将程序运行所需的一部分装入内存进行执行 采用逻辑地址 当不执行时，会释放占用内存 可以动态的申请存储空间以满足程序的需求 动态存储分配采用覆盖和交换技术实现 地址的重定位为了实现动态存储分配，我们需要通过逻辑地址去映射物理地址。 首先我们要了解逻辑地址和物理地址 逻辑地址是人们为了方便变成，用一些符号或名称表示的内存地址，是虚拟的。 物理地址是实实在在对应存储器的地址。 重定位，也叫地址映射，作用是将逻辑地址转换为物理地址，常用两种方法： 静态地址重定位 地址变换只是在装入时一次完成，以后不改变 优点： 实现容易 缺点： 用户必须分配一个连续的存储空间 难以实现程序和数据的共享 动态地址重定位 通过硬件地址变换机构将逻辑地址转换为物理地址 优点： 有利于提高主存的利用率和存储空间使用的灵活性 有利于实现数据的共享 缺点： 实现存储器管理的软件比较复杂 需要附加的硬件支持 覆盖与交换覆盖和交换是从逻辑上扩充主存的两种方法，解决了在较小主存空间中如何执行大程序的问题。 覆盖 当CPU要求某一段程序执行时，才将该程序装入主存中覆盖以前的某一段程序。 要求程序设计人员给出程序段之间的覆盖结构，主要在同一个进程或作业中进行。 可以在较小的存储空间中运行容量较大的进程或作业。 交换将系统暂时不用的程序或数据部分从主存中调出来，以腾出更大的存储空间。 主要在进程或作业之间进行。 可以在较小的存储空间中运行较多的进程或作业。 单道环境下的存储管理 单道系统的存储空间一般划分为三部分：系统区，用户区，剩余空间区。 采用单一连续区存储管理，同一时刻只允许一个用户进程使用，主要采用静态存储分配方式，即用户程序一旦调入主存后，必须等到该程序执行结束后才能释放主存空间。 这种方式的特点： 优点： 管理简单 只需要很少的软硬件支持 缺点： 系统存储空间浪费较大 执行效率低 数据不能共享 多道程序的存储管理分区存储管理固定分区法 固态分区是指系统在初始化时，将主存空间划分为若干固定大小的区域，用户进程在执行过程中，不允许改变划分区域的大小。 缺点：不能充分利用存储器资源，有一部分内存会由于未被进程占用而浪费，这一部分浪费称为“碎拼”或“内零头” 动态分区法 采用动态分区时，主存部分只有一个空闲区域，随后根据程序大小分配合适的存储空间。 缺点：在程序运行时，有些数据是当前不需要的，而这部分数据仍然占据内存空间，导致空间利用率低。 分区存储管理的优缺点 优点： 要求的硬件支持少，管理容易，实现简单 缺点： 由于每次装入的都是一整个程序，有些程序数据不会被利用，导致内存资源利用率低 当内存有一定空间时，由于不能满足某个作业的所需大小，这块内存空间就会被闲置，导致浪费。 没有实现虚拟存储,即在小内存的计算机中，不能运行需要大内存才能运行的程序。 页式存储管理页式管理的思想是：将程序分配在不连续的大小相同的存储区域中，实现主存“见缝插针”式的分配，同时保证作业的连续执行。 页式存储取消了存储分配的连续性，他能使用户进程分配到不连续的存储单元中。 静态页式存储管理静态页式存储管理是指用户作业在开始执行以前，将作业的程序和数据全部装入到主存中（数同一作业数据在内存中的可以使分散的），然后，操作系统通过地址转换，利用逻辑地址完成相应操作。 缺点：无法实现虚拟存储技术 虚拟页式存储管理采用了虚拟存储技术，在用户作业开始执行以前，只将运行时所需数据存入主存中，而后利用逻辑地址完成相应操作。 当出现所需数据不在内存中时，这种情况叫做“缺页中断”，这时我们需要采用合适的页面置换算法，将磁盘中的所需数据替换掉内存中不需要的数据。 优化算法先进先出算法最近最少用置换算法时钟算法段式存储管理在页式存储管理中，要求用户程序的逻辑地址空间是连续的。就这要求用户源程序进行编译时，将各种数据按照线性装配，不方便，不灵活。 而段式存储管理把用户作业按照功能分段，分别装入内存的不同位置 段页式存储管理段页式即将段式和页式相结合，克服了上述两种方式的缺点。","link":"/2019/11/22/IT/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/"},{"title":"【算法】绪论","text":"时间复杂度T(n)时间复杂度的公式是： T(n) = O( f(n) )；其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：算法的渐进时间复杂度。 通常n取无穷大，那么一些常数就可以被省略 常见的时间复杂度量级有： 常数阶O(1) 对数阶O(logN) 线性阶O(n) 线性对数阶O(nlogN) 平方阶O(n²) 立方阶O(n³) K次方阶O(n^k) 指数阶(2^n) 空间复杂度空间复杂度的公式是： S(n) = O( f(n) )；空间复杂度并不是指算法实际占用的空间大小，而是指，随着量级n的变化，需要的辅助空间的大小。 常用的空间复杂度： O(1) O(n) O(n²)","link":"/2019/11/23/IT/%E7%AE%97%E6%B3%95/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%BB%AA%E8%AE%BA/"},{"title":"【算法】分支限界算法","text":"分支限界算法类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。 分支搜索算法所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。 选择下一个E-结点的方式不同，则会有几种不同的分支搜索方式。 1）FIFO搜索 2）LIFO搜索 3）优先队列式搜索 由于求解目标不同，导致分支限界法与回溯法在解空间树T上的搜索方式也不相同。回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。","link":"/2019/11/23/IT/%E7%AE%97%E6%B3%95/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E7%AE%97%E6%B3%95/"},{"title":"【算法】回溯法","text":"回溯法 在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。 解题框架步骤也是利用了递归，其实本质上也是一种“在所有情况中遍历出解”的方法 123456789101112131415void backtrack(int t) //t表示递归深度，即当前扩展节点在解空间树的深度{ if ( t &gt; n ) output(x); //n控制递归深度，如果算法已经搜索到叶节点，记录输出可行解X else { for(int i = f(n,t) ; i &lt;= g(n,t) ; i++) //在深度t，i从未搜索过得起始编号到终止编号 { x[t] = h(i); //查看i这个点的值是否满足题目的要求 if( constraint(t) &amp;&amp; bound(t)) backtrack(t+1) //constraint（t）为true表示在当前扩展节点处x[1:t]的取值满足问题的约束条件； //bound(t)为true表示当前扩展节点取值没有使目标函数越界； //为true表示还需要进一步的搜索子树，否则减去子树。 } }","link":"/2019/11/23/IT/%E7%AE%97%E6%B3%95/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%9E%E6%BA%AF%E6%B3%95/"},{"title":"【算法】分治策略","text":"分治思想分治法的设计思想是，将一个难以解决的大问题，分割成一些规模较小的相同问题，以便逐个击破，分而治之。所以使用分治策略时，常常会用到递归（不断地分治）。 递归要想领会分治的思想，就要先理解递归，“递归”这个词可以拆分成两个字来解释 递：有传递的意思，也就是递归算法所对应的方法，要有参数，并且自己调用自身时，也要传递参数。 归：是指自身调用自身是有限度的，最后会“归一” 但需要注意的是，递归算法的运行效率很低，非常耗费内存 斐波那契数列就是一个常见的使用递归的例子 斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, … 如果设F(n）为该数列的第n项（n∈N*），那么这句话可以写成如下形式 F(n)=F(n-1)+F(n-2)，其中f(1)=f(2)=1; 分治策略的解题步骤 将原问题划分或归结为较小规模的子问题 递归或迭代求解每个子问题 将子问题综合得到原问题的解 注意： 子问题与原始问题性质完全一样 子问题间可彼此独立的求解 递归停止时，子问题可直接求解 算法实例二分检索算法棋盘覆盖问题二分归并排序","link":"/2019/11/23/IT/%E7%AE%97%E6%B3%95/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"},{"title":"【算法】动态规划","text":"动态规划动态规划思想动态规划问题的求解过程是多阶段决策的过程，每一步处理一个决策。常用于求最优解的问题。 注意：这里问题是由多个阶段的“决策”组成，而不是“问题”。这两者还是有细微差别的。 这里为了方便解释，举例说明： 这里参考【北大公开课】算法设计的例子 https://www.bilibili.com/video/av7134874?p=36 这是一个求最短路径的问题，要求从S点走到T点的路径最短。（任意S到任意T，只能向右走） 解： 我们可以把一个大问题划分为多个子决策的组合，这些子决策拥有相同的等级；在这里，大的决策是从S走到T，我们可以把这个大决策化解为S到A，A到B，B到C，C到T； 与通常的思路不同，我们并不是从起点开始阶段，而是从终点向前推进，找出每一个子决策的最优解 最终可以计算得出结果如下图： 动态规划解决了什么问题动态规划通常用于解决包含了多个阶段决策的最优解问题。 使用动态规划的条件具有最优子结构性质：一个最优决策序列的任何子序列，也一定是一个最优决策序列。 动态规划方向性 首先要理解“后边界不变，前边界前移”，参考本文刚开始举出的最短路径的例子，解决子问题的顺序是从终点到起点的。 算法实例背包问题","link":"/2019/11/23/IT/%E7%AE%97%E6%B3%95/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"【算法】贪心算法","text":"贪心算法贪心算法 ： 在每一步选择中都采取在当前状态下最好或最优的选择，从而希望导致结果是最好或最优的算法（也就是说，结果不一定是最优解）。 经典例子——找换硬币问题考虑用最少的硬币数 来找 n 分钱的问题，假设每个硬币的值都是整数。 这里的贪心策略很容易想到：总是优先选择 大面值的硬币 去找。比如，现有 1分、5分、25分的硬币可用来找钱，现在我们需要找 n=32分 的零钱，如何找？ 优先选择大面值的嘛，那就是先选 25分；选完之后，还要找32-25=7，那就再选5分的，最终再先2个1分的。即可。 算法实例哈夫曼编码最小生成树","link":"/2019/11/23/IT/%E7%AE%97%E6%B3%95/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"title":"密码加密技术","text":"为什么要对密码加密有一些不负责任的WEB应用，数据库中的密码是使用明文存储的，一旦数据库泄露，就会造成很严重的后果，由于绝大多数用户在多个不同平台的账号密码往往是相同的，黑客就会利用在数据库中获取的账号和明文密码，去访问各大平台，这会造成连带的后果，十分危险。 CSDN 就是这样的典型案例。非常不幸的是，存明文密码的网站不在少数，而且不少是很多所谓的有公信力的大网站。 什么是彩虹表对于不可逆的加密，最简单的破解就是构造一个巨大的彩虹表（rainbow table） 简单说就是穷举可能的密码组合，比如遍历所有9位数字，从10000,0000到99999,9999将每个数字的md5 hash散列存入数据库。 然后当用户查询某个加密后的字符串md5 hash时，就去这个数据库里查询挨个比对，如果能查到，就可以反推出原字符串是多少。如果查不出来，也只能说明这个rainbow table不够大，没有包含用户的密码,本质上这就是一种暴力攻击brute force attack 盐Salt一般来说，最简单的提升加密强度的方法就是“加盐”，也就是所谓的salt。这样的话，能极大提升攻击成本，因为对于每位用户的密码，都加了不同的salt，这样你每破解一个用户的密码，都需要重建一次彩虹表。时间成本及其巨大。 常用的加密算法MD5由于彩虹表的存在，MD5加密也变得不再安全 SHA1同上 Bcrypt12345678910111213@Testvoid contextLoads() { //随机加盐 String a=BCrypt.hashpw(\"123\", BCrypt.gensalt()); String b=BCrypt.hashpw(\"123\", BCrypt.gensalt()); //$2a$10$17d/IxKfkPTBJHKlWB8EHOJxBQT7BABQqV505T3g5bLq4atiYIT4i System.out.println(a); //$2a$10$F7BL9/w10ktDjrMT9dVTOO.SrO7zjGjQsQ/PQr.qtlU.HXb1147Si System.out.println(b); //true System.out.println(BCrypt.checkpw(\"123\",a)); //true System.out.println(BCrypt.checkpw(\"123\",b));} 从上述代码可以看出，每一次加盐都是随机的，而且同一个密码理论上可以对应无数种结果，这使得暴力方法变得不可取。当然，在当前计算机的计算水平是很难完成的，量子计算出现以后，暴力方法会变得很简单。 如何进行相对安全的加密推荐利用：hash+随机salt+自己算法，这种杂揉的方式。","link":"/2019/11/23/IT/%E5%85%B6%E4%BB%96/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"管程和PV信号量","slug":"管程和PV信号量","link":"/tags/%E7%AE%A1%E7%A8%8B%E5%92%8CPV%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"name":"死锁活锁","slug":"死锁活锁","link":"/tags/%E6%AD%BB%E9%94%81%E6%B4%BB%E9%94%81/"},{"name":"同步互斥","slug":"同步互斥","link":"/tags/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"彩虹表","slug":"彩虹表","link":"/tags/%E5%BD%A9%E8%99%B9%E8%A1%A8/"},{"name":"密码加密","slug":"密码加密","link":"/tags/%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/"},{"name":"安全","slug":"安全","link":"/tags/%E5%AE%89%E5%85%A8/"}],"categories":[{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"IT","slug":"IT","link":"/categories/IT/"},{"name":"Java","slug":"IT/Java","link":"/categories/IT/Java/"},{"name":"计算机网络","slug":"IT/计算机网络","link":"/categories/IT/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"操作系统","slug":"IT/操作系统","link":"/categories/IT/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"算法","slug":"IT/算法","link":"/categories/IT/%E7%AE%97%E6%B3%95/"},{"name":"其他","slug":"IT/其他","link":"/categories/IT/%E5%85%B6%E4%BB%96/"}]}
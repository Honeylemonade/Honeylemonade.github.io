{"pages":[],"posts":[{"title":"My First Blog","text":"My First Blog经历了大约两天的时间，终于将博客改造成了自己喜欢的形式 从真正开始接触计算机，到现在，也已经大概两年的时间了，对于知识的管理，经历了很多阶段。从一开始的纸质笔记本，到x-mind文档，再到Markdown笔记。虽然，期间经历过资料的损坏，丢失，但现在仍保存着绝大部分的内容。现在决定转换阵地——博客。 首先，我并不是一个所谓的”技术宅“，我对生活的也是充满着热情的，也有很多想要尝试，去做的事情，像是： 去学习有关人体构造以及运动学方面的知识 去学唱歌，并掌握一种乐器 去了解经济学，对自己的财政情况时刻保持清醒的认识 学习室内设计，在将来有自己的房子的时候，可以进行DIY 所以，博客的内容将不仅限于计算机方面的知识，在未来，也会包含运动，音乐，经济学相关的内容。当然，在这个过程中，相信我的文笔也会越来越好。 正如本文的配图——“Let‘s have a hike.” 这不仅是一个新的起点，也是一个不断积累的过程。愿我可以成为我想成为的人。","link":"/2019/11/17/%E5%85%B6%E4%BB%96/My%20First%20Blog/"},{"title":"【Java】数组与集合","text":"数组 声明数组有两种方式 int[] a 和 int a[]，推荐使用：int[] a（变量类型都在左边） 12345public static void main(String[] args) { //等价于 int[] a=new int[10]; int[] a; a=new int[10]; } 创建数组时，有默认值 数字数组，默认为：0 boolean数组，默认为：false 对象数组，默认为：null 一旦创建数组后，就不能再去改变它的大小 数组之间使用=时，表示两个变量引用同一个数组 如果想要拷贝一个新的数组，可以使用Arrays.copyOf() 数组排序，Arrays.sort(a)，采用了快速排序的方法 123456789//对于情况E，赋值会产生空指针异常。java.lang.NullPointerExceptionfloat [][]f = new float[6][];f[0][1] = 1.0f;System.out.println(f[0][1]);//若要访问，需要创建数组，并指向该地址。float [][]f = new float[6][];f[0] = new float[5];f[0][1] = 1.0f;System.out.println(f[0][1]); 快速初始化数组 1234 boolean[] a=new boolean[10]; Arrays.fill(a,true); System.out.println(a[0]);//输出ture 集合集合体系及特点 这里给出常用的一些接口和实现类，实际上远比这个要复杂：可以使用IDEA查看diagram Collection 是集合类的一个顶级接口 Collection是单列集合 Collection中只有Set系列要求元素唯一 List接口 List是元素有序并且可以重复的集合，称为序列 List可以精确的控制每个元素的插入位置，或删除某个位置的元素 ArrayList类： ArrayList底层是由数组实现的，长度动态增长（没超过边界一次，容量就会自动扩大为原来的1.5倍） 由于是用数组实现的，当在某个不是头尾的位置进行插入删除时，需要移动其位置后面的所有元素，效率很低，所以增删速度慢 由于是用数组实现的，索引速度快，所以更适合查询和更新元素 LinkedList类： 是基于链表结构实现的 基于链表实现，所以查询速度慢 基于链表实现，所以增删速度快 vector类： 底层也是由数组实现的，每次扩容扩大为原来的2倍 Vector 是很多方法都有用synchronize修饰，也就是说，可以做到线程安全，但性能比较低 stack类： 栈 Set接口 Set是元素无序的 元素不可以重复，称为集 HashSet类： HashSet是Set接口的重要实现类，称为哈希集 HashSet中的元素无序并且不可以重复 具有良好的存取和查找性能 TreeSet类： TreeSet是基于二叉树的数据结构 可以在插入的时候，自然的排序 Map Map中的数据是以键值对(key-value)的形式存储的，是双列集合 可以通过key值快速查找value key值不能重复，但是value可以重复 HashMap类： 基于哈希表的Map接口的实现 HashMap中的Entry对象是无序排列的 Tips关于静态容器类的初始化，可以用双花括号解决： 1234567private static ArrayList&lt;Contact&gt; contacts = new ArrayList&lt;Contact&gt;() {{ add(new Contact(5468754, \"a\")); add(new Contact(4468754, \"b\")); add(new Contact(7468754, \"c\")); add(new Contact(2468754, \"d\")); add(new Contact(6468754, \"e\")); }}; 迭代器接口： 用与遍历集合元素的接口，共包含4个方法 next（）：返回值，并且向下移动 hasNext（） remove（） forEachRemaining（） 1234567891011121314@Test public void test() { ArrayList&lt;Integer&gt; list = new ArrayList(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); //获取集合的迭代器 Iterator it = list.iterator(); while (it.hasNext()) { System.out.println(it.next()); } } for-each语法糖： JAVA中for-each的底层实现就是利用了迭代器，for-each其实只是java提供的语法糖。语法糖是编程语言提供的一些便于程序员书写代码的语法，是编译器提供给程序员的糖衣，编译时会对这些语法特殊处理。语法糖虽然不会带来实质性的改进，但是在提高代码可读性，提高语法严谨性，减少编码错误机会上确实做出了很大贡献。 集合类常用方法： size（） isEmpty（） contains（） clear（） toArray（）","link":"/2019/11/20/IT/java/%E3%80%90Java%E3%80%91%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88/"},{"title":"【Java】继承与接口","text":"枚举什么是枚举Emum是在Java5中引入的新特性，从那开始，它被广泛的用在不同的Java应用中。Enum是一个Java的关键字，用于表示一个固定的常用值。例如，每周的天数，每年的月数等。Enum是一种类型，就像Class和Interface可以用于定义一系列的Enum常量 枚举的特点 Enum常量隐式的加上了static和final，一旦被创建就无法修改，所以是线程安全的 Enum提供了是类型安全的(type-safe) Enum隐式的加上了values()方法，返回一个数组包含所有的Enum常量 两个Enum常量可以使用 ==或equals()方法比较 Enum可以用在switch语句中，就像int，String。 Enum有自己的名称空间 Enum可以实现Java接口 可以在Enum中定义构造器 所有的enums隐式的extend了java.lang.Enum类，因为一个类只能extend一个父亲，所以enum不能extend其它的类。但是Enum可以实现许多接口。 枚举的使用12345678910111213// 外部声明Enumenum Color { RED,GREEN,BLUE;}public class Test{ public static void main(String[] args) { Color c1 = Color.RED; //输出RED System.out.println(c1); }} 枚举的原理12345678910111213141516171819202122//案例代码enum AccountType implements Serializable,Cloneable{ SAVING, FIXED, CURRENT; private AccountType() { System.out.println(\"It is a account type\"); }}class Main{ public static void main(String[]args) { System.out.println(AccountType.FIXED); }}//输出结果It is a account typeIt is a account typeIt is a account typeFIXED 枚举类在后台实现时，实际上是转化为一个继承了java.lang.Enum类的实体类，原先的枚举类型变成对应的实体类型，上例中AccountType变成了个class AccountType，并且会生成一个新的构造函数，若原来有构造函数，则在此基础上添加两个参数，生成新的构造函数，如上例子中： 123private AccountType(){ System.out.println(“It is a account type”); } 会变成： 1234private AccountType(String s, int i){ super(s,i); System.out.println(“It is a account type”); } 而在这个类中，会添加若干字段来代表具体的枚举类型： 123public static final AccountType SAVING;public static final AccountType FIXED;public static final AccountType CURRENT; 而且还会添加一段static代码段： 12345static{ SAVING = new AccountType(\"SAVING\", 0); CURRENT = new AccountType(\"CURRENT\", 0); $VALUES = new AccountType[]{ SAVING, FIXED, CURRENT }} 以此来初始化枚举中的每个具体类型。（并将所有具体类型放到一个$VALUE数组中，以便用序号访问具体类型） 在初始化过程中new AccountType构造函数被调用了三次，所以Enum中定义的构造函数中的打印代码被执行了3遍。 异常异常的结构分类 所有的异常都是继承了Thowable。 Error：是运行时系统错误，或者资源耗尽错误等，是没办法解决的，这时应该通告用户，并尽力使程序安全终止 Exception：又分为两种 RuntimeException：当出现这种异常时，一定时程序本身存在问题，可能是错误的类型转换，数组越界，空指针等等 非RuntimeException：可能是I/O异常，文件不存在，类不存在等等 受检异常和非受检异常非受检异常指的是java.lang.RuntimeException和java.lang.Error类及其子类，所有其他的异常类都称为受检异常。 那么什么是受检异常和非受检异常呢？ 受检异常的特点在于它强制要求开发人员在代码中进行显式的声明和捕获，否则就会产生编译错误。这种限制从好的方面来说，可以防止开发人员意外地忽略某些出错的情况，因为编译器不允许出现未被处理的受检异常 非受检异常的特点是，如果不捕获异常，不会产生编译错误，异常会在运行时刻才被抛出。 异常的用法throw和throws关键字Throw用于抛出异常对象，后面跟的时异常对象。是语句抛出一个异常。多用在函数内。 语法：throw(异常对象) ​ throw e; Throws是方法可能抛出异常的声明（用在声明方法时，表示该方法可能要抛出异常） 语法：修饰符 返回值类型 方法名 参数类型 throws异常类 ​ public void test throws Exception1,Exception2(){} finally关键字 finally声明的代码段中，即使代码已经进入了返回值阶段，也一定会在程序程序末尾执行 1234567891011121314151617public class Main { public static int getNumber() { try { System.out.println(\"try\"); return 1; } catch (Exception e) { System.out.println(e); } finally { return -1; } } public static void main(String[] args) { //输出结果-1 System.out.println(getNumber()); }} 正则表达式java正则表达式的实现，是利用了java.util.regex包下的Pattern类与Matcher类 Pattern类（制定匹配规则） 创建pattern对象： 12Pattern p=Pattern.compile(\"\\\\w+\"); p.pattern();//返回 \\w+ 根据正则分隔字符串：返回一个String[] 123Pattern p=Pattern.compile(\"\\\\d+\"); String[] str=p.split(\"我的QQ是:456456我的电话是:0532214我的邮箱是:aaa@aaa.com\"); //结果:str[0]=\"我的QQ是:\" str[1]=\"我的电话是:\" str[2]=\"我的邮箱是:aaa@aaa.com\" Pattern.matcher(String regex,CharSequence input)是一个静态方法,用于快速匹配字符串,该方法适合用于只匹配一次,且匹配全部字符串 123Pattern.matches(\"\\\\d+\",\"2223\");//返回true Pattern.matches(\"\\\\d+\",\"2223aa\");//返回false,需要匹配到所有字符串才能返回true,这里aa不能匹配到 Pattern.matches(\"\\\\d+\",\"22bb23\");//返回false,需要匹配到所有字符串才能返回true,这里bb不能匹配到 通过pattern返回matcher对象，Matcher类的构造方法也是私有的,不能随意创建,只能通过Pattern.matcher(CharSequence input)方法得到该类的实例. 123Pattern p=Pattern.compile(\"\\\\d+\"); Matcher m=p.matcher(\"22bb23\"); m.pattern();//返回p 也就是返回该Matcher对象是由哪个Pattern对象的创建的 Matcher类（查看匹配情况） 查看匹配情况 12345Pattern p=Pattern.compile(\"\\\\d+\"); Matcher m=p.matcher(\"22bb23\"); m.matches();//返回false,因为bb不能被\\d+匹配,导致整个字符串匹配未成功. Matcher m2=p.matcher(\"2223\"); m2.matches();//返回true,因为\\d+匹配到了整个字符串 lookingAt()对前面的字符串进行匹配,只有匹配到的字符串在最前面才返回true 12345Pattern p=Pattern.compile(\"\\\\d+\"); Matcher m=p.matcher(\"22bb23\"); m.lookingAt();//返回true,因为\\d+匹配到了前面的22 Matcher m2=p.matcher(\"aa2223\"); m2.lookingAt();//返回false,因为\\d+不能匹配前面的aa find()对字符串进行匹配,匹配到的字符串可以在任何位置 123456789Pattern p=Pattern.compile(\"\\\\d+\"); Matcher m=p.matcher(\"22bb23\"); m.find();//返回true Matcher m2=p.matcher(\"aa2223\"); m2.find();//返回true Matcher m3=p.matcher(\"aa2223bb\"); m3.find();//返回true Matcher m4=p.matcher(\"aabb\"); m4.find();//返回false 返回匹配的位置 123456789101112131415161718Pattern p=Pattern.compile(\"\\\\d+\"); Matcher m=p.matcher(\"aaa2223bb\"); m.find();//匹配2223 m.start();//返回3 m.end();//返回7,返回的是2223后的索引号 m.group();//返回2223 Mathcer m2=m.matcher(\"2223bb\"); m.lookingAt(); //匹配2223 m.start(); //返回0,由于lookingAt()只能匹配前面的字符串,所以当使用lookingAt()匹配时,start()方法总是返回0 m.end(); //返回4 m.group(); //返回2223 Matcher m3=m.matcher(\"2223bb\"); m.matches(); //匹配整个字符串 m.start(); //返回0,原因相信大家也清楚了 m.end(); //返回6,原因相信大家也清楚了,因为matches()需要匹配所有字符串 m.group(); //返回2223bb groupCount()用于返回有多少组 12345678910Pattern p=Pattern.compile(\"([a-z]+)(\\\\d+)\"); Matcher m=p.matcher(\"aaa2223bb\"); m.find(); //匹配aaa2223 m.groupCount(); //返回2,因为有2组 m.start(1); //返回0 返回第一组匹配到的子字符串在字符串中的索引号 m.start(2); //返回3 m.end(1); //返回3 返回第一组匹配到的子字符串的最后一个字符在字符串中的索引位置. m.end(2); //返回7 m.group(1); //返回aaa,返回第一组匹配到的子字符串 m.group(2); //返回2223,返回第二组匹配到的子字符串","link":"/2019/11/19/IT/java/%E3%80%90Java%E3%80%91%E6%9E%9A%E4%B8%BE%EF%BC%8C%E5%BC%82%E5%B8%B8%EF%BC%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"【Java】简介及基础概念","text":"Java简介Java的发源1991年1月，一个名为“Green Project”的项目启动。该项目旨在为家用电器提供支持，使这些电器智能化并且能够彼此交互，而且这些家电可以由远程客户端控制。Bill Joy、James Gosling、Mike Sheradin和Patrick Naughton是该项目的核心成员。 JAVA原名是“Oak”，橡树的意思，但后来发现有已经有编程语言叫做Oak，所以改名为JAVA Java语言发展情况 版本 年份 新特性 1.0 1996 语言本身 1.1 1997 内部类 1.2 1998 strictfp修饰符 1.3 2000 无 1.4 2002 断言 5.0 2004 泛型类，for each，循环，自动装箱，枚举，静态导入 6 2006 无 7 2011 基于字串的switch，钻石操作符，二进制字面量，异常处理的改进 8 2014 lambda表达式，包含默认方法的接口，流和日期/时间库 Java基础概念注释注释共分为三种： //：简单的注释 /* */：比较长的注释，可以是多行 /** */：javadoc，会自动的生成文档 基本数据类型Java共有8种数据类型，包括4个整型，2个浮点型，1个字符型，1个boolean型 序号 数据类型 封装类 默认值 可表示范围 特征 1 byte(字节) Byte 0 -128~127 一个字节 2 short(短整数) Short 0 -32768~32767 两个字节 3 int(整数) Integer 0 -2147483648~2147483647 四个字节 4 long(长整数) Long 0L -9223372036854775808~9223372036854775807 八个字节 5 float(单精度) Float 0.0F 1.4E-45~3.4028235E38 6 double(双精度) Double 0.0D 4.9E-324~1.7976931348623157E308 7 char(字符) Character ‘’ 0~65535 8 boolean（布尔值） Boolean false true或false Tips： java没有无符号类型 int int型数较大，不方便观察时，可以使用_（下划线）进行分隔，例如：int a = 800_0000; 内存中存储的实际上是整形的补码 0x开头代表16进制，0开头代表8进制 long 长整型数值后面有一个L后缀：4000000000L 浮点型 浮点型不能用于金融的计算，比如：2.0-1.1=0.8999999，是因为二进制不能精确的表示1/10，就像十进制不能精确表示1/3（应该使用BigDecimal类） char型 JAVA中所有的字符类型都占用2个字节，包括中文和英文 boolean Java中的boolean（布尔）类型不能和整型相互转换 字符串String为了节省内存空间，JVM底层对String类型进行了优化，存在着“常量池”。 一个对象在常量池中，当有需要时，直接使用常量池中的引用，而不是重新创建，这样可以节约空间，提高性能。 由于是常量，不存在“改变”，所以完全不用担心多个代码块对同一引用的使用会造成错误。 123456789101112131415public static void main(String[] args) { //先去String常量池中查找是否已经存在“abc” //没有找到，则在String常量池中新建“abc”字符串常量 String a = \"abc\"; //在String常量池中找到“abc”，将其引用直接赋值给变量 String b = \"abc\"; //直接new String（“abc”）创建一个新的字符串对象，创建的对象不在字符串常量池中 String c = new String(\"abc\"); //结果为true System.out.println(a == b); //结果为false System.out.println(a == c); //结果为true System.out.println(a.equals(c)); } Tips String不可变，但可以修改其引用，达到修改某个变量的目的 当字符串+=后，会生成新的字符串对象 判断字串是否相同，要用equals（）方法，直接使用==判断的是两个引用是否为同一个，不同引用的字符串可能相同的 if( str !=null &amp;&amp; str.length() !=0 )判断字符串长度时，要先判断其是否为null，然后再判断长度，这里利用了&amp;&amp;的短路功能 运算符算数运算法 +，-，*，/ ++，– %：取余数 这里要注意取余和取模的区别，这两者的基本步骤相同： 求整数商：c=a/b 计算余数或模：r=a-c*b 两者的不同在于第一步：“求整数商” 取模求时，第一步的商向0方向舍入 而求余时，第一步的商向负无穷方向舍入 例如：7和-2做取余和取模运算 步骤 求余数 求模数 1 7/-2=-3.5，商向0舍入，∴c=-3 7/-2=-3.5，商向负无穷舍入，∴c=-4 2 r=a-c*b=1 r=a-c*b=-1 123456public void test() { //取余，结果为1 System.out.println(7 % -2); //取模，结果为-1 System.out.println(Math.floorMod(7, -2)); } 位运算符 &amp;，|，~，^：按顺序分别是与，或，非，异或 &lt;&lt;，&gt;&gt;：左移和右移 &gt;&gt;&gt;无符号右移 逻辑运算符 &amp;，|，！，^：与，或，非，异或 &amp;&amp;，||：短路与，短路或 Tips 整数被0除将会产生异常，而浮点数被0除，会得到无穷大或者NaN（Not a Number）的结果 负数的%(取余)，可能会取到负数 数学Math类： 平方根，幂运算， Math的floorMod求模 Math提供了近似于PI和E的常量：Math.PI和Math.E 想要进行四舍五入运算可以使用Math.round() Math.random()生成随机数 &amp;&amp;和||是逻辑运算符，做的是短路操作，既当前一部分已经确定true或者false后，后一部分将不再进行运算 位运算符 1234567891011121314151617181920212223242526public static void main(String[] args) { /**--------------------------------------------------- * ^(亦或运算)：相同的为0，不同的为1 * 2 =======&gt;0010 * 3 =======&gt;0011 * 2^3就为0001，结果就是1 *--------------------------------------------------- * &amp;（与运算）：有一个为0，就是0 * 2 =======&gt;0010 * 3 =======&gt;0011 * 2&amp;3就为0010，结果就是2 *--------------------------------------------------- * 另外还有|或运算，~非运算 *--------------------------------------------------- * &lt;&lt;(向左位移) * 2 =======&gt;0010 * 向左移3位，可以理解成称了3次2 * 2&lt;&lt;3运算的结果是 :16 *--------------------------------------------------- * &gt;&gt;(向右位移)：同上 *--------------------------------------------------- * &gt;&gt;&gt;(无符号右移) :不常用，涉及到补码， * 正数做&gt;&gt;&gt;运算的时候和&gt;&gt;是一样的。区别在于负数运算 * --------------------------------------------------- */ } 类型转换数据之间进行类型转换时，常用如下几种方法：截断，包装类方法 截断截断包括两类： 高精度截断为低精度 123456public static void main(String[] args) { double a=9.9997; int b=(int)a; //输出结果为9 System.out.println(b);} 大范围截断为小范围 12345public static void main(String[] args) { int a = (byte) 300; //输出结果为44 System.out.println(a); } 包装类1包装类.valueOf(); 控制流程常用的控制流程语句 if else while，do while for for each switch 方法方法的组成 修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。 返回值类型 ：方法可能会返回值。但有些没有返回值。在这种情况下，returnValueType 是关键字void。 方法名：是方法的实际名称。方法名和参数表共同构成方法签名。 参数类型：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。 方法体：方法体包含具体的语句，定义该方法的功能。 方法参数的值传递首先，我们要知道Java方法参数总是按值调用，也就是说，方法得到的参数，是一个变量的值的拷贝。 方法参数共有两种类型： 对于基本数据类型来说，传递的是拷贝的值 对于对象来说，传递的是对象的引用 构造方法当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。 通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。 不管你是否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，默认构造方法的访问修改符和类的访问修改符相同(类为 public，构造函数也为 public；类改为 private，构造函数也改为 private)。 一旦你定义了自己的构造方法，默认构造方法就会失效。 finalize() 方法Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( ) 例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。 在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。 方法重载方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。 原则如下： 方法名一定要相同。 方法的参数表必须不同，包括参数的类型或个数，以此区分不同的方法体。 方法的返回类型、修饰符可以相同，也可不同。","link":"/2019/11/18/IT/java/%E3%80%90Java%E3%80%91%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"title":"【Java】类与对象","text":"类与对象概述Java的设计体现了面向对象的思想，一切皆为对象（除了基本数据类型），面向对象包括三个特性： 封装 继承 多态 类就像是一个模板，而对象就是根据这个“模板”制作出的产品。 类包括4种访问控制权限，如下： 关键字 说明 private 仅对本类可见 default（默认省略） 对本包可见 protected 对本包和所有子类可见 public 对所有类可见 对象和对象变量1234public static void main(String[] args) { //a是一个对象变量，而new Date()则创建了一个对象 Date a = new Date();} 其中，对象变量获取的是对象的引用。 static关键字首先要理解“静态域”的概念，静态域是伴随于类存在的，和对象无关，也就是说，当已经存在一个类时，无需声明其对象，就已经拥有了静态域内的所有资源。并且，每一个类有且仅有一个静态域，且静态域是封闭的，既静态域中的方法，不能调用非静态域的属性。 静态变量和静态常量（类数据）静态变量不常用用，但静态常量却用的比较多，比如：Math.PI，一般静态常量用final关键字修饰，为了保证其不被修改 使用类数据的两种方法： 通过类去定位数据：Math.PI(推荐) 通过对象去定位数据：Math math=new Math()；math.PI 静态方法（类方法）静态方法，是静态域中的内容，不能调用非静态域中的属性，但可以访问自身静态域中的属性 在下面两种情况下，可能使用静态方法： 一个方法不需要访问对象的状态 一个方法只需要访问其静态域 通过this指针了解staticstatic方法就是没有this的方法，而普通的方法是由对象调用的，所以有 this 抽象类 抽象类是普通类和接口的折中，拥有普通类和接口两者的特性！！！！ 抽象类可以包括抽象方法和非抽象方法 普通类中的方法就是非抽象方法，这种方法不强制要求其子类去实现什么，继承后即可使用。 而接口中的方法则为抽象方法，必须由实现接口的类去完成具体功能的实现。 一个类只能继承一个抽象类，而一个类却可以实现多个接口 普通类的单继承的 而接口是多实现的 从上述特点可以看出：抽象类是普通类和接口的折中 从另一个角度理解：抽象类要求其子类必须实现某种接口 Java中常用的类Date Date类采用的是UTC时间 打印出的格式为：Tue Aug 20 15:25:05 CST 2019 同时包含了年月日时分秒 LocalDate 采用的是当地的标准时间，例如在中国，采用的是公历 打印出来的格式为：2019-08-20 只包含年月日 创建对象不是使用构造器，而使用静态的.of()方法 1234public static void main(String[] args) { LocalDate a = LocalDate.of(2011, 8, 20); System.out.println(a.getYear()); } LocalDate可以自定义日期 还可以计算多少天之后的日期，可用于会员日期的计算 12345public static void main(String[] args) { LocalDate a = LocalDate.of(2019, 8, 20); LocalDate b=a.plusDays(1000); System.out.println(b); } LocalTime和LocalDateTime基本使用方法可以参考LocalDate Math Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。 Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。 Random可以进行随机生成，其实是伪随机（以时间为种子） 大数值类当基本的整数和浮点数的精度或大小范围不够用时，可以使用BigInteger和BigDecimal（可以处理任意长度数值） 声明变量比较特殊 不能使用熟悉的运算符去运算此类 123456789public static void main(String[] args) { //声明大数值类型 BigInteger a = BigInteger.valueOf(100); BigInteger b = BigInteger.valueOf(1000); //相当于a+b BigInteger c = a.add(b); //相当于a*b BigInteger d = a.multiply(b); } 包装类 包装类和基本数据类型之间可以自动装箱和拆箱 用包装类做相等比较的时候，要使用equals，原因是“==”比较的是包装类声明的对象的引用 包装类对象值不能改变，并且包装类都用final修饰，不能被继承 8中基本数据类型都有对应的包装类，这里用int的包装类，Integer为例： Integer.parseInt(“1024”); Integer.valueOf(“1024”).intValue(); 这两个返回值都为int型 parseInt（）：是Integer中的静态方法，将数据转换为int型（可以由函数名称看出） Integer.valueOf（）：可以将数据转换为Integer类型 intValue是Integer对象的内置方法，用与将Integer类型转换为int型（但是其实由自动装箱和拆箱）","link":"/2019/11/18/IT/java/%E3%80%90Java%E3%80%91%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"title":"【Java】泛型","text":"泛型泛型的意义没有约束的自由，称不上为自由，这也正是泛型存在的意义，他一方面限制了代码的自由，一方面又使得代码变得自由。 限制了自由这里说的限制了自由，其实是为了避免代码出错，变得难以管理，这里举个例子： 既然我们已经有了全能的Object类，为什么还需要泛型呢？ 最初没有泛型的时候，Arraylist是使用Object类来实现的，但是这样做，存在两个问题： 当获取一个值时，必须进行强制的类型转换 1String name=(String) arrayList.get(0); 没错类型检查，一个Arraylist中可以添加任意对象 但是当引入了泛型之后，ArrayList变量在声明时变决定了类型，所以这样就解决了上述两个问题。 让代码变得自由这一点体现在提高了代码的复用率，例如： 12345678910@Data@NoArgsConstructor@AllArgsConstructorpublic class Pair&lt;T&gt; { private T first; private T seconde; public void test(){ Pair&lt;String&gt; pair = new Pair(); }} 泛型的原理其实泛型的底层实现，靠的是使用的时Object类，运行时类型参数会被擦掉。例如，无论你声明的的是List&lt;String&gt;，还是List&lt;Integer&gt;或者原生类List，容器实际类型都是List&lt;Object&gt;。 所以泛型实际上都是狼外婆，它看上去像外婆，但实际上是大灰狼。 泛型实现的原理是类型的擦除，所以不能使用基本数据类型当作泛型的类型 泛型实现的原理是类型的擦除，所以不能将泛型和数组同时使用 Tips 常用的缩写 E：表示元素集合 K和V：表示关键字类型和值类型 T：表示任意类型(常用) 不仅仅是类上声明泛型，在方法上也可以声明泛型。 泛型的类型可以进行条件限定： Class类是泛型类","link":"/2019/11/19/IT/java/%E3%80%90Java%E3%80%91%E6%B3%9B%E5%9E%8B/"},{"title":"【Java】继承与接口","text":"继承继承的概念继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 兔子和羊属于食草动物类，狮子和豹属于食肉动物类。 食草动物和食肉动物又是属于动物类。 所以继承需要符合的关系是：is-a，父类更通用，子类更具体。 Tips 子类拥有父类非private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，单继承就是一个子类只能继承一个父类。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。 使用final关键字可以阻止子类继承：final关键字不仅可以声明在类上，也可以生命在类方法上 Object类——所有类的父类equals方法用于判断两个对象是否具有相同的引用，代码实现使用的是“==” 123public boolean equals(Object obj) { return (this == obj); } 重写equals方法应该严格按照规定来做，共5步 hashcode方法用于返回一个对象的散列值 应用场景：集合Map，不允许出现相同元素，当我们插入一个对象时，如果使用==一个个的去比较是否是同一对象，在数量少的时候，还可以接受，当数量很大时，一个个去比较，显然很不合理，于是我们可以利用hashcode，直接得出为一的标识，去查找目表对象。 toString方法用于返回对象字符串，常用于打印对象当前的状态信息 cloneable接口用于标识类是可以被复制的，用protected声明 首先我们先理解一下 浅拷贝和 深拷贝 浅拷贝：对象中的深一层对象，采用的是同一个实例引用 深拷贝：对象中的深层对象，采用的是不用的实例引用 实现深拷贝的方法： 实现cloneable接口，并自定义clone方法（比较麻烦） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Data@NoArgsConstructor@AllArgsConstructorpublic class Teacher implements Cloneable { String name; Integer age; @Override public String toString() { return \"Teacher{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); }}@Data@NoArgsConstructor@AllArgsConstructorpublic class MyClass implements Cloneable { Teacher teacher; Integer Number; @Override public String toString() { return \"MyClass{\" + \"teacher=\" + teacher.toString() + \", Number=\" + Number + '}'; } @Override protected Object clone() throws CloneNotSupportedException { MyClass cloned = (MyClass) super.clone(); cloned.teacher = (Teacher) teacher.clone(); return cloned; }} public static void main(String[] args) throws Exception { Teacher teacher = new Teacher(\"王华\", 32); MyClass a = new MyClass(teacher, 100); MyClass b= (MyClass) a.clone(); System.out.println(a.toString()); System.out.println(b.toString()); a.teacher.age=11; System.out.println(a.toString()); System.out.println(b.toString()); } 使用对象的串行化 使用已有的工具包 浅谈多继承的优缺点 C++支持多继承，而很多语言例如，java不支持多继承，“不支持”并不是说技术上难以实现，而是多继承存在一些问题 优点： 有利于类的复用，方便与扩展 缺点： 二义性：如果多个父类的方法名相同，则不知道要调用谁的方法 接口接口的概念 接口（英文：Interface），在Java编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过实现接口，从实现对应的功能。 接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。 接口定义：接口是对类的一组需求的描述，这些类要遵从接口的描述进行定义 接口中的所有方法自动的属于public，因此不需要提供关键字public 接口不能被实例化，但可以声明接口的变量 接口中可以定义常量（但不推荐使用），接口中定义的常量应为所有类频繁使用的常量, 但并不是每个类都使用了接口中定义的所有常量，建议常量定义在实现类中 JAVA只能单继承，但是可以实现多个接口 接口中可以定义静态方法 接口中，使用default关键字定义的方法，可在接口中实现方法体，并且实现该接口的类，可以选择是否重写该接口 接口和继承 继承：继承是一种泛化的过程，使一个抽象的类更加生动具体，更专注于整个类的定义。 实现接口：接口的实现，像是一种功能的补充，至于功能怎么实现，取决于实现该接口的类。","link":"/2019/11/18/IT/java/%E3%80%90Java%E3%80%91%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%8E%A5%E5%8F%A3/"}],"tags":[{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"IT","slug":"IT","link":"/categories/IT/"},{"name":"Java","slug":"IT/Java","link":"/categories/IT/Java/"}]}
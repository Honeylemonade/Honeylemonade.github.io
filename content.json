{"pages":[],"posts":[{"title":"My First Blog","text":"My First Blog经历了大约两天的时间，终于将博客改造成了自己喜欢的形式 从真正开始接触计算机，到现在，也已经大概两年的时间了，对于知识的管理，经历了很多阶段。从一开始的纸质笔记本，到x-mind文档，再到Markdown笔记。虽然，期间经历过资料的损坏，丢失，但现在仍保存着绝大部分的内容。现在决定转换阵地——博客。 首先，我并不是一个所谓的”技术宅“，我对生活的也是充满着热情的，也有很多想要尝试，去做的事情，像是： 去学习有关人体构造以及运动学方面的知识 去学唱歌，并掌握一种乐器 去了解经济学，对自己的财政情况时刻保持清醒的认识 学习室内设计，在将来有自己的房子的时候，可以进行DIY 所以，博客的内容将不仅限于计算机方面的知识，在未来，也会包含运动，音乐，经济学相关的内容。当然，在这个过程中，相信我的文笔也会越来越好。 正如本文的配图——“Let‘s have a hike.” 这不仅是一个新的起点，也是一个不断积累的过程。愿我可以成为我想成为的人。","link":"/2019/11/17/%E5%85%B6%E4%BB%96/My%20First%20Blog/"},{"title":"【Java】简介及基础概念","text":"Java简介Java的发源1991年1月，一个名为“Green Project”的项目启动。该项目旨在为家用电器提供支持，使这些电器智能化并且能够彼此交互，而且这些家电可以由远程客户端控制。Bill Joy、James Gosling、Mike Sheradin和Patrick Naughton是该项目的核心成员。 JAVA原名是“Oak”，橡树的意思，但后来发现有已经有编程语言叫做Oak，所以改名为JAVA Java语言发展情况 版本 年份 新特性 1.0 1996 语言本身 1.1 1997 内部类 1.2 1998 strictfp修饰符 1.3 2000 无 1.4 2002 断言 5.0 2004 泛型类，for each，循环，自动装箱，枚举，静态导入 6 2006 无 7 2011 基于字串的switch，钻石操作符，二进制字面量，异常处理的改进 8 2014 lambda表达式，包含默认方法的接口，流和日期/时间库 Java基础概念注释注释共分为三种： //：简单的注释 /* */：比较长的注释，可以是多行 /** */：javadoc，会自动的生成文档 基本数据类型Java共有8种数据类型，包括4个整型，2个浮点型，1个字符型，1个boolean型 序号 数据类型 封装类 默认值 可表示范围 特征 1 byte(字节) Byte 0 -128~127 一个字节 2 short(短整数) Short 0 -32768~32767 两个字节 3 int(整数) Integer 0 -2147483648~2147483647 四个字节 4 long(长整数) Long 0L -9223372036854775808~9223372036854775807 八个字节 5 float(单精度) Float 0.0F 1.4E-45~3.4028235E38 6 double(双精度) Double 0.0D 4.9E-324~1.7976931348623157E308 7 char(字符) Character ‘’ 0~65535 8 boolean（布尔值） Boolean false true或false Tips： java没有无符号类型 int int型数较大，不方便观察时，可以使用_（下划线）进行分隔，例如：int a = 800_0000; 内存中存储的实际上是整形的补码 0x开头代表16进制，0开头代表8进制 long 长整型数值后面有一个L后缀：4000000000L 浮点型 浮点型不能用于金融的计算，比如：2.0-1.1=0.8999999，是因为二进制不能精确的表示1/10，就像十进制不能精确表示1/3（应该使用BigDecimal类） char型 JAVA中所有的字符类型都占用2个字节，包括中文和英文 boolean Java中的boolean（布尔）类型不能和整型相互转换 字符串String为了节省内存空间，JVM底层对String类型进行了优化，存在着“常量池”。 一个对象在常量池中，当有需要时，直接使用常量池中的引用，而不是重新创建，这样可以节约空间，提高性能。 由于是常量，不存在“改变”，所以完全不用担心多个代码块对同一引用的使用会造成错误。 123456789101112131415public static void main(String[] args) { //先去String常量池中查找是否已经存在“abc” //没有找到，则在String常量池中新建“abc”字符串常量 String a = \"abc\"; //在String常量池中找到“abc”，将其引用直接赋值给变量 String b = \"abc\"; //直接new String（“abc”）创建一个新的字符串对象，创建的对象不在字符串常量池中 String c = new String(\"abc\"); //结果为true System.out.println(a == b); //结果为false System.out.println(a == c); //结果为true System.out.println(a.equals(c)); } Tips String不可变，但可以修改其引用，达到修改某个变量的目的 当字符串+=后，会生成新的字符串对象 判断字串是否相同，要用equals（）方法，直接使用==判断的是两个引用是否为同一个，不同引用的字符串可能相同的 if( str !=null &amp;&amp; str.length() !=0 )判断字符串长度时，要先判断其是否为null，然后再判断长度，这里利用了&amp;&amp;的短路功能 运算符算数运算法 +，-，*，/ ++，– %：取余数 这里要注意取余和取模的区别，这两者的基本步骤相同： 求整数商：c=a/b 计算余数或模：r=a-c*b 两者的不同在于第一步：“求整数商” 取模求时，第一步的商向0方向舍入 而求余时，第一步的商向负无穷方向舍入 例如：7和-2做取余和取模运算 步骤 求余数 求模数 1 7/-2=-3.5，商向0舍入，∴c=-3 7/-2=-3.5，商向负无穷舍入，∴c=-4 2 r=a-c*b=1 r=a-c*b=-1 123456public void test() { //取余，结果为1 System.out.println(7 % -2); //取模，结果为-1 System.out.println(Math.floorMod(7, -2)); } 位运算符 &amp;，|，~，^：按顺序分别是与，或，非，异或 &lt;&lt;，&gt;&gt;：左移和右移 &gt;&gt;&gt;无符号右移 逻辑运算符 &amp;，|，！，^：与，或，非，异或 &amp;&amp;，||：短路与，短路或 Tips 整数被0除将会产生异常，而浮点数被0除，会得到无穷大或者NaN（Not a Number）的结果 负数的%(取余)，可能会取到负数 数学Math类： 平方根，幂运算， Math的floorMod求模 Math提供了近似于PI和E的常量：Math.PI和Math.E 想要进行四舍五入运算可以使用Math.round() Math.random()生成随机数 &amp;&amp;和||是逻辑运算符，做的是短路操作，既当前一部分已经确定true或者false后，后一部分将不再进行运算 位运算符 1234567891011121314151617181920212223242526public static void main(String[] args) { /**--------------------------------------------------- * ^(亦或运算)：相同的为0，不同的为1 * 2 =======&gt;0010 * 3 =======&gt;0011 * 2^3就为0001，结果就是1 *--------------------------------------------------- * &amp;（与运算）：有一个为0，就是0 * 2 =======&gt;0010 * 3 =======&gt;0011 * 2&amp;3就为0010，结果就是2 *--------------------------------------------------- * 另外还有|或运算，~非运算 *--------------------------------------------------- * &lt;&lt;(向左位移) * 2 =======&gt;0010 * 向左移3位，可以理解成称了3次2 * 2&lt;&lt;3运算的结果是 :16 *--------------------------------------------------- * &gt;&gt;(向右位移)：同上 *--------------------------------------------------- * &gt;&gt;&gt;(无符号右移) :不常用，涉及到补码， * 正数做&gt;&gt;&gt;运算的时候和&gt;&gt;是一样的。区别在于负数运算 * --------------------------------------------------- */ } 类型转换数据之间进行类型转换时，常用如下几种方法：截断，包装类方法 截断截断包括两类： 高精度截断为低精度 123456public static void main(String[] args) { double a=9.9997; int b=(int)a; //输出结果为9 System.out.println(b);} 大范围截断为小范围 12345public static void main(String[] args) { int a = (byte) 300; //输出结果为44 System.out.println(a); } 包装类1包装类.valueOf(); 控制流程常用的控制流程语句 if else while，do while for for each switch 方法方法的组成 修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。 返回值类型 ：方法可能会返回值。但有些没有返回值。在这种情况下，returnValueType 是关键字void。 方法名：是方法的实际名称。方法名和参数表共同构成方法签名。 参数类型：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。 方法体：方法体包含具体的语句，定义该方法的功能。 方法参数的值传递首先，我们要知道Java方法参数总是按值调用，也就是说，方法得到的参数，是一个变量的值的拷贝。 方法参数共有两种类型： 对于基本数据类型来说，传递的是拷贝的值 对于对象来说，传递的是对象的引用 构造方法当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。 通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。 不管你是否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，默认构造方法的访问修改符和类的访问修改符相同(类为 public，构造函数也为 public；类改为 private，构造函数也改为 private)。 一旦你定义了自己的构造方法，默认构造方法就会失效。 finalize() 方法Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( ) 例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。 在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。 方法重载方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。 原则如下： 方法名一定要相同。 方法的参数表必须不同，包括参数的类型或个数，以此区分不同的方法体。 方法的返回类型、修饰符可以相同，也可不同。","link":"/2019/11/18/IT/java/%E3%80%90Java%E3%80%91%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"title":"【Java】类与对象","text":"类与对象概述Java的设计体现了面向对象的思想，一切皆为对象（除了基本数据类型），面向对象包括三个特性： 封装 继承 多态 类就像是一个模板，而对象就是根据这个“模板”制作出的产品。 对象和对象变量1234public static void main(String[] args) { //a是一个对象变量，而new Date()则创建了一个对象 Date a = new Date();} 其中，对象变量获取的是对象的引用。 static关键字首先要理解“静态域”的概念，静态域是伴随于类存在的，和对象无关，也就是说，当已经存在一个类时，无需声明其对象，就已经拥有了静态域内的所有资源。并且，每一个类有且仅有一个静态域，且静态域是封闭的，既静态域中的方法，不能调用非静态域的属性。 静态变量和静态常量（类数据）静态变量不常用用，但静态常量却用的比较多，比如：Math.PI，一般静态常量用final关键字修饰，为了保证其不被修改 使用类数据的两种方法： 通过类去定位数据：Math.PI(推荐) 通过对象去定位数据：Math math=new Math()；math.PI 静态方法（类方法）静态方法，是静态域中的内容，不能调用非静态域中的属性，但可以访问自身静态域中的属性 在下面两种情况下，可能使用静态方法： 一个方法不需要访问对象的状态 一个方法只需要访问其静态域 通过this指针了解staticstatic方法就是没有this的方法，而普通的方法是由对象调用的，所以有 this 抽象类 抽象类是普通类和接口的折中，拥有普通类和接口两者的特性！！！！ 抽象类可以包括抽象方法和非抽象方法 普通类中的方法就是非抽象方法，这种方法不强制要求其子类去实现什么，继承后即可使用。 而接口中的方法则为抽象方法，必须由实现接口的类去完成具体功能的实现。 一个类只能继承一个抽象类，而一个类却可以实现多个接口 普通类的单继承的 而接口是多实现的 从上述特点可以看出：抽象类是普通类和接口的折中 从另一个角度理解：抽象类要求其子类必须实现某种接口 Java中常用的类Date Date类采用的是UTC时间 打印出的格式为：Tue Aug 20 15:25:05 CST 2019 同时包含了年月日时分秒 LocalDate 采用的是当地的标准时间，例如在中国，采用的是公历 打印出来的格式为：2019-08-20 只包含年月日 创建对象不是使用构造器，而使用静态的.of()方法 1234public static void main(String[] args) { LocalDate a = LocalDate.of(2011, 8, 20); System.out.println(a.getYear()); } LocalDate可以自定义日期 还可以计算多少天之后的日期，可用于会员日期的计算 12345public static void main(String[] args) { LocalDate a = LocalDate.of(2019, 8, 20); LocalDate b=a.plusDays(1000); System.out.println(b); } LocalTime和LocalDateTime基本使用方法可以参考LocalDate Math Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。 Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。 Random可以进行随机生成，其实是伪随机（以时间为种子） 大数值类当基本的整数和浮点数的精度或大小范围不够用时，可以使用BigInteger和BigDecimal（可以处理任意长度数值） 声明变量比较特殊 不能使用熟悉的运算符去运算此类 123456789public static void main(String[] args) { //声明大数值类型 BigInteger a = BigInteger.valueOf(100); BigInteger b = BigInteger.valueOf(1000); //相当于a+b BigInteger c = a.add(b); //相当于a*b BigInteger d = a.multiply(b); } 包装类8中基本数据类型都有对应的包装类，这里用int的包装类，Integer为例： Integer.parseInt(“1024”); Integer.valueOf(“1024”).intValue(); 这两个返回值都为int型 parseInt（）：是Integer中的静态方法，将数据转换为int型（可以由函数名称看出） Integer.valueOf（）：可以将数据转换为Integer类型 intValue是Integer对象的内置方法，用与将Integer类型转换为int型（但是其实由自动装箱和拆箱）","link":"/2019/11/18/IT/java/%E3%80%90Java%E3%80%91%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Java基","slug":"Java基","link":"/tags/Java%E5%9F%BA/"}],"categories":[{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"IT","slug":"IT","link":"/categories/IT/"},{"name":"Java","slug":"IT/Java","link":"/categories/IT/Java/"}]}